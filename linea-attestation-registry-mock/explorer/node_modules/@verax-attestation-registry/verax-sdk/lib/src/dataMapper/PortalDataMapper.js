"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseDataMapper_1 = __importDefault(require("./BaseDataMapper"));
const DefaultPortal_1 = require("../abi/DefaultPortal");
const abiCoder_1 = require("../utils/abiCoder");
const PortalRegistry_1 = require("../abi/PortalRegistry");
const simulationErrorHandler_1 = require("../utils/simulationErrorHandler");
const transactionSender_1 = require("../utils/transactionSender");
class PortalDataMapper extends BaseDataMapper_1.default {
    constructor() {
        super(...arguments);
        this.typeName = "portal";
        this.gqlInterface = `{
        id
        ownerAddress
        modules
        isRevocable
        name
        description
        ownerName
  }`;
    }
    async simulateAttest(portalAddress, attestationPayload, validationPayloads) {
        const matchingSchema = await this.veraxSdk.schema.findOneById(attestationPayload.schemaId);
        if (!matchingSchema) {
            throw new Error("No matching Schema");
        }
        const attestationData = (0, abiCoder_1.encode)(matchingSchema.schema, attestationPayload.attestationData);
        return this.simulatePortalContract(portalAddress, "attest", [
            [attestationPayload.schemaId, attestationPayload.expirationDate, attestationPayload.subject, attestationData],
            validationPayloads,
        ]);
    }
    async attest(portalAddress, attestationPayload, validationPayloads, waitForConfirmation = false) {
        const request = await this.simulateAttest(portalAddress, attestationPayload, validationPayloads);
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async simulateBulkAttest(portalAddress, attestationPayloads, validationPayloads) {
        const attestationPayloadsArg = [];
        for (const attestationPayload of attestationPayloads) {
            const matchingSchema = await this.veraxSdk.schema.findOneById(attestationPayload.schemaId);
            if (!matchingSchema) {
                throw new Error("No matching Schema");
            }
            const attestationData = (0, abiCoder_1.encode)(matchingSchema.schema, attestationPayload.attestationData);
            attestationPayloadsArg.push([
                attestationPayload.schemaId,
                attestationPayload.expirationDate,
                attestationPayload.subject,
                attestationData,
            ]);
        }
        return this.simulatePortalContract(portalAddress, "bulkAttest", [attestationPayloadsArg, validationPayloads]);
    }
    async bulkAttest(portalAddress, attestationPayloads, validationPayloads, waitForConfirmation = false) {
        const request = await this.simulateBulkAttest(portalAddress, attestationPayloads, validationPayloads);
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async simulateRevoke(portalAddress, attestationId) {
        return this.simulatePortalContract(portalAddress, "revoke", [attestationId]);
    }
    async revoke(portalAddress, attestationId, waitForConfirmation = false) {
        const request = await this.simulateRevoke(portalAddress, attestationId);
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async simulateBulkRevoke(portalAddress, attestationIds) {
        return this.simulatePortalContract(portalAddress, "bulkRevoke", [attestationIds]);
    }
    async bulkRevoke(portalAddress, attestationIds, waitForConfirmation = false) {
        const request = await this.simulateBulkRevoke(portalAddress, attestationIds);
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async simulateReplace(portalAddress, attestationId, attestationPayload, validationPayloads) {
        const matchingSchema = await this.veraxSdk.schema.findOneById(attestationPayload.schemaId);
        if (!matchingSchema) {
            throw new Error("No matching Schema");
        }
        const attestationData = (0, abiCoder_1.encode)(matchingSchema.schema, attestationPayload.attestationData);
        return this.simulatePortalContract(portalAddress, "replace", [
            attestationId,
            [attestationPayload.schemaId, attestationPayload.expirationDate, attestationPayload.subject, attestationData],
            validationPayloads,
        ]);
    }
    async replace(portalAddress, attestationId, attestationPayload, validationPayloads, waitForConfirmation = false) {
        const request = await this.simulateReplace(portalAddress, attestationId, attestationPayload, validationPayloads);
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async simulateBulkReplace(portalAddress, attestationIds, attestationPayloads, validationPayloads) {
        const attestationPayloadsArg = [];
        for (const attestationPayload of attestationPayloads) {
            const matchingSchema = await this.veraxSdk.schema.findOneById(attestationPayload.schemaId);
            if (!matchingSchema) {
                throw new Error("No matching Schema");
            }
            const attestationData = (0, abiCoder_1.encode)(matchingSchema.schema, attestationPayload.attestationData);
            attestationPayloadsArg.push([
                attestationPayload.schemaId,
                attestationPayload.expirationDate,
                attestationPayload.subject,
                attestationData,
            ]);
        }
        return this.simulatePortalContract(portalAddress, "bulkReplace", [
            attestationIds,
            attestationPayloadsArg,
            validationPayloads,
        ]);
    }
    async bulkReplace(portalAddress, attestationIds, attestationPayloads, validationPayloads, waitForConfirmation = false) {
        const request = await this.simulateBulkReplace(portalAddress, attestationIds, attestationPayloads, validationPayloads);
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async simulateRegister(id, name, description, isRevocable, ownerName) {
        return this.simulatePortalRegistryContract("register", [id, name, description, isRevocable, ownerName]);
    }
    async register(id, name, description, isRevocable, ownerName, waitForConfirmation = false) {
        const request = await this.simulateRegister(id, name, description, isRevocable, ownerName);
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async simulateDeployDefaultPortal(modules, name, description, isRevocable, ownerName) {
        return this.simulatePortalRegistryContract("deployDefaultPortal", [
            modules,
            name,
            description,
            isRevocable,
            ownerName,
        ]);
    }
    async deployDefaultPortal(modules, name, description, isRevocable, ownerName, waitForConfirmation = false) {
        const request = await this.simulateDeployDefaultPortal(modules, name, description, isRevocable, ownerName);
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async getPortalByAddress(id) {
        return this.executePortalRegistryReadMethod("getPortalByAddress", [id]);
    }
    async isPortalRegistered(id) {
        return this.executePortalRegistryReadMethod("isRegistered", [id]);
    }
    async executePortalRegistryReadMethod(functionName, args) {
        return this.web3Client.readContract({
            abi: PortalRegistry_1.abiPortalRegistry,
            address: this.conf.portalRegistryAddress,
            functionName,
            args,
        });
    }
    async simulatePortalRegistryContract(functionName, args) {
        if (!this.walletClient)
            throw new Error("VeraxSDK - Wallet not available");
        try {
            const { request } = await this.web3Client.simulateContract({
                address: this.conf.portalRegistryAddress,
                abi: PortalRegistry_1.abiPortalRegistry,
                functionName,
                account: this.walletClient.account,
                args,
            });
            return request;
        }
        catch (err) {
            (0, simulationErrorHandler_1.handleSimulationError)(err);
        }
    }
    async simulatePortalContract(portalAddress, functionName, args) {
        if (!this.walletClient)
            throw new Error("VeraxSDK - Wallet not available");
        try {
            const { request } = await this.web3Client.simulateContract({
                address: portalAddress,
                abi: DefaultPortal_1.abiDefaultPortal,
                functionName,
                account: this.walletClient.account,
                args,
            });
            return request;
        }
        catch (err) {
            (0, simulationErrorHandler_1.handleSimulationError)(err);
        }
    }
}
exports.default = PortalDataMapper;
//# sourceMappingURL=PortalDataMapper.js.map