{
  "version": 3,
  "sources": ["../../viem/errors/ccip.ts", "../../viem/utils/address/isAddressEqual.ts", "../../viem/utils/ccip.ts"],
  "sourcesContent": ["import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type OffchainLookupErrorType = OffchainLookupError & {\n  name: 'OffchainLookupError'\n}\nexport class OffchainLookupError extends BaseError {\n  override name = 'OffchainLookupError'\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n      },\n    )\n  }\n}\n\nexport type OffchainLookupResponseMalformedErrorType =\n  OffchainLookupResponseMalformedError & {\n    name: 'OffchainLookupResponseMalformedError'\n  }\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  override name = 'OffchainLookupResponseMalformedError'\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n      },\n    )\n  }\n}\n\nexport type OffchainLookupSenderMismatchErrorType =\n  OffchainLookupSenderMismatchError & {\n    name: 'OffchainLookupSenderMismatchError'\n  }\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  override name = 'OffchainLookupSenderMismatchError'\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n      },\n    )\n  }\n}\n", "import type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { isAddress } from './isAddress.js'\n\nexport type IsAddressEqualReturnType = boolean\nexport type IsAddressEqualErrorType = InvalidAddressErrorType | ErrorType\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a)) throw new InvalidAddressError({ address: a })\n  if (!isAddress(b)) throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n", "import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport { type BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  OffchainLookupResponseMalformedError,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport { HttpRequestError } from '../errors/request.js'\nimport type { Chain } from '../types/chain.js'\nimport type { GetErrorArgs } from '../types/contract.js'\nimport type { Hex } from '../types/misc.js'\n\nimport type { Client } from '../clients/createClient.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport type OffchainLookupErrorType = ErrorType\n\nexport async function offchainLookup<TChain extends Chain | undefined,>(\n  client: Client<Transport, TChain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  }) as unknown as GetErrorArgs<\n    [typeof offchainLookupAbiItem],\n    'OffchainLookup'\n  >\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = await ccipFetch({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport type CcipFetchErrorType = ErrorType\n\nexport async function ccipFetch({\n  data,\n  sender,\n  urls,\n}: { data: Hex; sender: Address; urls: readonly string[] }) {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method =\n      url.includes('{sender}') || url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          method,\n        },\n      )\n\n      let result\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: stringify(result.error) || response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n"],
  "mappings": "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",
  "names": []
}
