"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getOnSubgraphExecute = exports.getTransportExecutor = exports.createTransportGetter = exports.defaultTransportsOption = void 0;
const utils_1 = require("@graphql-mesh/utils");
const utils_2 = require("@graphql-tools/utils");
function defaultTransportsOption(transportKind) {
    return Promise.resolve(`${`@graphql-mesh/transport-${transportKind}`}`).then(s => __importStar(require(s))).catch(err => {
        console.error(err);
        throw new Error(`No transport found for ${transportKind}. Please install @graphql-mesh/transport-${transportKind}`);
    });
}
exports.defaultTransportsOption = defaultTransportsOption;
function createTransportGetter(transports) {
    if (typeof transports === 'function') {
        return transports;
    }
    return function getTransport(transportKind) {
        const transport = transports[transportKind];
        if (!transport) {
            throw new Error(`No transport found for ${transportKind}`);
        }
        return transport;
    };
}
exports.createTransportGetter = createTransportGetter;
function getTransportExecutor(transportGetter, transportContext) {
    transportContext.logger?.info(`Loading transport ${transportContext.transportEntry?.kind}`);
    const transport$ = transportGetter(transportContext.transportEntry?.kind);
    return (0, utils_1.mapMaybePromise)(transport$, transport => transport.getSubgraphExecutor(transportContext));
}
exports.getTransportExecutor = getTransportExecutor;
function getOnSubgraphExecute({ fusiongraph, plugins, transports, transportBaseContext, transportEntryMap, subgraphMap, }) {
    const onSubgraphExecuteHooks = [];
    if (plugins) {
        for (const plugin of plugins) {
            if (plugin.onSubgraphExecute) {
                onSubgraphExecuteHooks.push(plugin.onSubgraphExecute);
            }
        }
    }
    const subgraphExecutorMap = {};
    const transportGetter = createTransportGetter(transports);
    function onSubgraphExecute(subgraphName, executionRequest) {
        let executor = subgraphExecutorMap[subgraphName];
        if (executor == null) {
            transportBaseContext?.logger?.info(`Initializing executor for subgraph ${subgraphName}`);
            const transportEntry = transportEntryMap[subgraphName];
            // eslint-disable-next-line no-inner-declarations
            function wrapExecutorWithHooks(currentExecutor) {
                if (onSubgraphExecuteHooks.length) {
                    return function executorWithHooks(executionRequest) {
                        const onSubgraphExecuteDoneHooks = [];
                        const subgraph = subgraphMap.get(subgraphName);
                        const onSubgraphExecuteHooksRes$ = (0, utils_1.iterateAsync)(onSubgraphExecuteHooks, onSubgraphExecuteHook => onSubgraphExecuteHook({
                            fusiongraph,
                            subgraph,
                            subgraphName,
                            transportEntry,
                            executionRequest,
                            setExecutionRequest(newExecutionRequest) {
                                executionRequest = newExecutionRequest;
                            },
                            executor: currentExecutor,
                            setExecutor(newExecutor) {
                                currentExecutor = newExecutor;
                            },
                        }), onSubgraphExecuteDoneHooks);
                        function handleOnSubgraphExecuteHooksResult() {
                            if (onSubgraphExecuteDoneHooks.length) {
                                // eslint-disable-next-line no-inner-declarations
                                function handleExecutorResWithHooks(currentResult) {
                                    const executeDoneResults = [];
                                    const onSubgraphExecuteDoneHooksRes$ = (0, utils_1.iterateAsync)(onSubgraphExecuteDoneHooks, onSubgraphExecuteDoneHook => onSubgraphExecuteDoneHook({
                                        result: currentResult,
                                        setResult(newResult) {
                                            currentResult = newResult;
                                        },
                                    }), executeDoneResults);
                                    function handleExecuteDoneResults(result) {
                                        if (!(0, utils_2.isAsyncIterable)(result)) {
                                            return result;
                                        }
                                        if (executeDoneResults.length === 0) {
                                            return result;
                                        }
                                        const onNextHooks = [];
                                        const onEndHooks = [];
                                        for (const executeDoneResult of executeDoneResults) {
                                            if (executeDoneResult.onNext) {
                                                onNextHooks.push(executeDoneResult.onNext);
                                            }
                                            if (executeDoneResult.onEnd) {
                                                onEndHooks.push(executeDoneResult.onEnd);
                                            }
                                        }
                                        return (0, utils_2.mapAsyncIterator)(result[Symbol.asyncIterator](), currentResult => {
                                            if (onNextHooks.length === 0) {
                                                return currentResult;
                                            }
                                            const $ = (0, utils_1.iterateAsync)(onNextHooks, onNext => onNext({
                                                result: currentResult,
                                                setResult: res => {
                                                    currentResult = res;
                                                },
                                            }));
                                            return (0, utils_1.mapMaybePromise)($, () => currentResult);
                                        }, undefined, () => onEndHooks.length === 0
                                            ? undefined
                                            : (0, utils_1.iterateAsync)(onEndHooks, onEnd => onEnd()));
                                    }
                                    return (0, utils_1.mapMaybePromise)(onSubgraphExecuteDoneHooksRes$, () => handleExecuteDoneResults(currentResult));
                                }
                                const executorRes$ = currentExecutor(executionRequest);
                                return (0, utils_1.mapMaybePromise)(executorRes$, handleExecutorResWithHooks);
                            }
                            return currentExecutor(executionRequest);
                        }
                        return (0, utils_1.mapMaybePromise)(onSubgraphExecuteHooksRes$, handleOnSubgraphExecuteHooksResult);
                    };
                }
                return currentExecutor;
            }
            executor = function lazyExecutor(subgraphExecReq) {
                const subgraph = subgraphMap.get(subgraphName);
                const executor$ = getTransportExecutor(transportGetter, transportBaseContext
                    ? {
                        ...transportBaseContext,
                        subgraphName,
                        subgraph,
                        transportEntry,
                    }
                    : { subgraph, transportEntry, subgraphName });
                return (0, utils_1.mapMaybePromise)(executor$, executor_ => {
                    executor = wrapExecutorWithHooks(executor_);
                    subgraphExecutorMap[subgraphName] = executor;
                    return executor(subgraphExecReq);
                });
            };
        }
        return executor(executionRequest);
    }
    return onSubgraphExecute;
}
exports.getOnSubgraphExecute = getOnSubgraphExecute;
