import e from"cross-fetch";import{Buffer as t}from"buffer";import{PrivateKey as n,encrypt as o,decrypt as i}from"eciesjs";import{EventEmitter2 as s}from"eventemitter2";import{validate as a,v4 as c}from"uuid";import{io as r}from"socket.io-client";function l(e,t,n,o){return new(n||(n=Promise))((function(i,s){function a(e){try{r(o.next(e))}catch(e){s(e)}}function c(e){try{r(o.throw(e))}catch(e){s(e)}}function r(e){var t;e.done?i(e.value):(t=e.value,t instanceof n?t:new n((function(e){e(t)}))).then(a,c)}r((o=o.apply(e,t||[])).next())}))}function d(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}"function"==typeof SuppressedError&&SuppressedError;var u,h,m={exports:{}};function g(){if(h)return u;h=1;var e=1e3,t=60*e,n=60*t,o=24*n,i=7*o,s=365.25*o;function a(e,t,n,o){var i=t>=1.5*n;return Math.round(e/n)+" "+o+(i?"s":"")}return u=function(c,r){r=r||{};var l=typeof c;if("string"===l&&c.length>0)return function(a){if((a=String(a)).length>100)return;var c=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(a);if(!c)return;var r=parseFloat(c[1]);switch((c[2]||"ms").toLowerCase()){case"years":case"year":case"yrs":case"yr":case"y":return r*s;case"weeks":case"week":case"w":return r*i;case"days":case"day":case"d":return r*o;case"hours":case"hour":case"hrs":case"hr":case"h":return r*n;case"minutes":case"minute":case"mins":case"min":case"m":return r*t;case"seconds":case"second":case"secs":case"sec":case"s":return r*e;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return r;default:return}}(c);if("number"===l&&isFinite(c))return r.long?function(i){var s=Math.abs(i);if(s>=o)return a(i,s,o,"day");if(s>=n)return a(i,s,n,"hour");if(s>=t)return a(i,s,t,"minute");if(s>=e)return a(i,s,e,"second");return i+" ms"}(c):function(i){var s=Math.abs(i);if(s>=o)return Math.round(i/o)+"d";if(s>=n)return Math.round(i/n)+"h";if(s>=t)return Math.round(i/t)+"m";if(s>=e)return Math.round(i/e)+"s";return i+"ms"}(c);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(c))}}var E=function(e){function t(e){let o,i,s,a=null;function c(...e){if(!c.enabled)return;const n=c,i=Number(new Date),s=i-(o||i);n.diff=s,n.prev=o,n.curr=i,o=i,e[0]=t.coerce(e[0]),"string"!=typeof e[0]&&e.unshift("%O");let a=0;e[0]=e[0].replace(/%([a-zA-Z%])/g,((o,i)=>{if("%%"===o)return"%";a++;const s=t.formatters[i];if("function"==typeof s){const t=e[a];o=s.call(n,t),e.splice(a,1),a--}return o})),t.formatArgs.call(n,e);(n.log||t.log).apply(n,e)}return c.namespace=e,c.useColors=t.useColors(),c.color=t.selectColor(e),c.extend=n,c.destroy=t.destroy,Object.defineProperty(c,"enabled",{enumerable:!0,configurable:!1,get:()=>null!==a?a:(i!==t.namespaces&&(i=t.namespaces,s=t.enabled(e)),s),set:e=>{a=e}}),"function"==typeof t.init&&t.init(c),c}function n(e,n){const o=t(this.namespace+(void 0===n?":":n)+e);return o.log=this.log,o}function o(e){return e.toString().substring(2,e.toString().length-2).replace(/\.\*\?$/,"*")}return t.debug=t,t.default=t,t.coerce=function(e){if(e instanceof Error)return e.stack||e.message;return e},t.disable=function(){const e=[...t.names.map(o),...t.skips.map(o).map((e=>"-"+e))].join(",");return t.enable(""),e},t.enable=function(e){let n;t.save(e),t.namespaces=e,t.names=[],t.skips=[];const o=("string"==typeof e?e:"").split(/[\s,]+/),i=o.length;for(n=0;n<i;n++)o[n]&&("-"===(e=o[n].replace(/\*/g,".*?"))[0]?t.skips.push(new RegExp("^"+e.slice(1)+"$")):t.names.push(new RegExp("^"+e+"$")))},t.enabled=function(e){if("*"===e[e.length-1])return!0;let n,o;for(n=0,o=t.skips.length;n<o;n++)if(t.skips[n].test(e))return!1;for(n=0,o=t.names.length;n<o;n++)if(t.names[n].test(e))return!0;return!1},t.humanize=g(),t.destroy=function(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")},Object.keys(e).forEach((n=>{t[n]=e[n]})),t.names=[],t.skips=[],t.formatters={},t.selectColor=function(e){let n=0;for(let t=0;t<e.length;t++)n=(n<<5)-n+e.charCodeAt(t),n|=0;return t.colors[Math.abs(n)%t.colors.length]},t.enable(t.load()),t};!function(e,t){t.formatArgs=function(t){if(t[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+t[0]+(this.useColors?"%c ":" ")+"+"+e.exports.humanize(this.diff),!this.useColors)return;const n="color: "+this.color;t.splice(1,0,n,"color: inherit");let o=0,i=0;t[0].replace(/%[a-zA-Z%]/g,(e=>{"%%"!==e&&(o++,"%c"===e&&(i=o))})),t.splice(i,0,n)},t.save=function(e){try{e?t.storage.setItem("debug",e):t.storage.removeItem("debug")}catch(e){}},t.load=function(){let e;try{e=t.storage.getItem("debug")}catch(e){}!e&&"undefined"!=typeof process&&"env"in process&&(e=process.env.DEBUG);return e},t.useColors=function(){if("undefined"!=typeof window&&window.process&&("renderer"===window.process.type||window.process.__nwjs))return!0;if("undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;return"undefined"!=typeof document&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||"undefined"!=typeof window&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)&&parseInt(RegExp.$1,10)>=31||"undefined"!=typeof navigator&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)},t.storage=function(){try{return localStorage}catch(e){}}(),t.destroy=(()=>{let e=!1;return()=>{e||(e=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),t.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"],t.log=console.debug||console.log||(()=>{}),e.exports=E(t);const{formatters:n}=e.exports;n.j=function(e){try{return JSON.stringify(e)}catch(e){return"[UnexpectedJSONParseError]: "+e.message}}}(m,m.exports);var v=d(m.exports);const y=v("KeyExchange:Layer"),C=v("SocketService:Layer"),p=v("Ecies:Layer"),S=v("RemoteCommunication:Layer");y.color="##95c44e",C.color="#f638d7",p.color="#465b9c",S.color="#47a2be";const f={KeyExchange:y,SocketService:C,Ecies:p,RemoteCommunication:S};let k,x=[],_=[];function I(t){return l(this,void 0,void 0,(function*(){if(!k||!t)return;!function(){const e=_;_=x,x=e}();const n=k.endsWith("/")?`${k}debug`:`${k}/debug`,o=Object.assign({},t);if(delete o.params,t.params)for(const[e,n]of Object.entries(t.params))o[e]=n;const i=JSON.stringify(o);f.RemoteCommunication(`[sendBufferedEvents] Sending ${x.length} analytics events to ${n}`);try{const t=yield e(n,{method:"POST",headers:{Accept:"application/json","Content-Type":"application/json"},body:i}),o=yield t.text();f.RemoteCommunication(`[sendBufferedEvents] Response: ${o}`),x.length=0}catch(e){console.warn("Error sending analytics",e)}}))}const K=(e,t)=>l(void 0,void 0,void 0,(function*(){var n;k=t,n=e,_.push(n),I(e).catch((()=>{}))}));class N{constructor(e){this.enabled=!0,(null==e?void 0:e.debug)&&v.enable("Ecies:Layer"),(null==e?void 0:e.pkey)?this.ecies=n.fromHex(e.pkey):this.ecies=new n,f.Ecies("[ECIES constructor()] initialized secret: ",this.ecies.toHex()),f.Ecies("[ECIES constructor()] initialized public: ",this.ecies.publicKey.toHex()),f.Ecies("[ECIES constructor()] init with",this)}generateECIES(){this.ecies=new n}getPublicKey(){return this.ecies.publicKey.toHex()}encrypt(e,n){let i=e;if(this.enabled)try{f.Ecies("[ECIES: encrypt()] using otherPublicKey",n);const s=t.from(e),a=o(n,s);i=t.from(a).toString("base64")}catch(t){throw f.Ecies("[ECIES: encrypt()] error encrypt:",t),f.Ecies("[ECIES: encrypt()] private: ",this.ecies.toHex()),f.Ecies("[ECIES: encrypt()] data: ",e),f.Ecies("[ECIES: encrypt()] otherkey: ",n),t}return i}decrypt(e){let n=e;if(this.enabled)try{f.Ecies("[ECIES: decrypt()] using privateKey",this.ecies.toHex());const o=t.from(e.toString(),"base64");n=i(this.ecies.toHex(),o).toString()}catch(t){throw f.Ecies("[ECIES: decrypt()] error decrypt",t),f.Ecies("[ECIES: decrypt()] private: ",this.ecies.toHex()),f.Ecies("[ECIES: decrypt()] encryptedData: ",e),t}return n}getKeyInfo(){return{private:this.ecies.toHex(),public:this.ecies.publicKey.toHex()}}toString(){f.Ecies("[ECIES: toString()]",this.getKeyInfo())}}var A={name:"@metamask/sdk-communication-layer",version:"0.18.5",description:"",homepage:"https://github.com/MetaMask/metamask-sdk#readme",bugs:{url:"https://github.com/MetaMask/metamask-sdk/issues"},repository:{type:"git",url:"https://github.com/MetaMask/metamask-sdk.git",directory:"packages/sdk-communication-layer"},main:"dist/node/cjs/metamask-sdk-communication-layer.js",unpkg:"dist/browser/umd/metamask-sdk-communication-layer.js",module:"dist/node/es/metamask-sdk-communication-layer.js",browser:"dist/browser/es/metamask-sdk-communication-layer.js","react-native":"dist/react-native/es/metamask-sdk-communication-layer.js",types:"dist/browser/es/src/index.d.ts",files:["/dist"],scripts:{build:"rimraf dist && rollup -c --bundleConfigAsCjs","build:tsc":"tsc","build:dev":"rimraf dist && NODE_ENV=dev rollup -c --bundleConfigAsCjs","build:post-tsc":"echo 'N/A'","build:pre-tsc":"echo 'N/A'",size:"size-limit",clean:"rimraf ./dist",lint:"yarn lint:eslint && yarn lint:misc --check","lint:changelog":"../../scripts/validate-changelog.sh @metamask/sdk-communication-layer","lint:eslint":"eslint . --cache --ext js,ts","lint:fix":"yarn lint:eslint --fix && yarn lint:misc --write","lint:misc":"prettier '**/*.json' '**/*.md' '!CHANGELOG.md' --ignore-path ../../.gitignore","prepare-manifest:preview":"../../scripts/prepare-preview-manifest.sh","publish:preview":"yarn npm publish --tag preview",prepack:"../../scripts/prepack.sh",reset:"yarn clean && rimraf ./node_modules/",test:"jest","test:coverage":"jest --coverage","test:ci":"jest --coverage --passWithNoTests --setupFilesAfterEnv ./jest-preload.js","test:dev":"jest",watch:"rollup -c --bundleConfigAsCjs -w"},dependencies:{bufferutil:"^4.0.8","date-fns":"^2.29.3",debug:"^4.3.4","utf-8-validate":"^6.0.3",uuid:"^8.3.2"},devDependencies:{"@jest/globals":"^29.3.1","@lavamoat/allow-scripts":"^2.3.1","@metamask/auto-changelog":"3.1.0","@metamask/eslint-config":"^6.0.0","@metamask/eslint-config-nodejs":"^6.0.0","@metamask/eslint-config-typescript":"^6.0.0","@rollup/plugin-commonjs":"^25.0.0","@rollup/plugin-json":"^6.0.0","@rollup/plugin-node-resolve":"^15.0.2","@rollup/plugin-terser":"^0.4.1","@size-limit/preset-big-lib":"^11.0.2","@types/jest":"^29.2.4","@types/node":"^20.1.3","@types/uuid":"^9.0.0","@typescript-eslint/eslint-plugin":"^4.26.0","@typescript-eslint/parser":"^4.26.0","cross-fetch":"^3.1.5",eciesjs:"^0.3.16",eslint:"^7.30.0","eslint-config-prettier":"^8.3.0","eslint-plugin-import":"^2.23.4","eslint-plugin-jest":"^24.4.0","eslint-plugin-jsdoc":"^36.1.0","eslint-plugin-node":"^11.1.0","eslint-plugin-prettier":"^3.4.0",eventemitter2:"^6.4.7",jest:"^29.3.1",prettier:"^2.3.0",rimraf:"^3.0.2",rollup:"^3.21.7","rollup-plugin-jscc":"^2.0.0","rollup-plugin-natives":"^0.7.5","rollup-plugin-node-builtins":"^2.1.2","rollup-plugin-node-globals":"^1.4.0","rollup-plugin-peer-deps-external":"^2.2.4","rollup-plugin-sizes":"^1.0.6","rollup-plugin-typescript2":"^0.31.2","rollup-plugin-visualizer":"^5.9.2","size-limit":"^11.0.2","socket.io-client":"^4.5.1","stream-browserify":"^3.0.0","ts-jest":"^29.0.3","ts-node":"^10.9.1",typescript:"^4.3.2"},peerDependencies:{"cross-fetch":"^3.1.5",eciesjs:"^0.3.16",eventemitter2:"^6.4.7","readable-stream":"^3.6.2","socket.io-client":"^4.5.1"},publishConfig:{access:"public",registry:"https://registry.npmjs.org/"},lavamoat:{allowScripts:{"@lavamoat/preinstall-always-fail":!1,canvas:!0,"eciesjs>secp256k1":!1,"socket.io-client>engine.io-client>ws>bufferutil":!1,"socket.io-client>engine.io-client>ws>utf-8-validate":!1,bufferutil:!1,"utf-8-validate":!1}}};const O="https://metamask-sdk.api.cx.metamask.io/",R=["websocket"],T=6048e5,w={METAMASK_GETPROVIDERSTATE:"metamask_getProviderState",ETH_REQUESTACCOUNTS:"eth_requestAccounts"};function b(e){const{context:t}=e;f.RemoteCommunication(`[RemoteCommunication: clean()] context=${t}`),e.channelConfig=void 0,e.ready=!1,e.originatorConnectStarted=!1}var D,$,L,M,P;!function(e){e.DISCONNECTED="disconnected",e.WAITING="waiting",e.TIMEOUT="timeout",e.LINKED="linked",e.PAUSED="paused",e.TERMINATED="terminated"}(D||(D={})),function(e){e.KEY_INFO="key_info",e.SERVICE_STATUS="service_status",e.PROVIDER_UPDATE="provider_update",e.RPC_UPDATE="rpc_update",e.KEYS_EXCHANGED="keys_exchanged",e.JOIN_CHANNEL="join_channel",e.CHANNEL_CREATED="channel_created",e.CLIENTS_CONNECTED="clients_connected",e.CLIENTS_DISCONNECTED="clients_disconnected",e.CLIENTS_WAITING="clients_waiting",e.CLIENTS_READY="clients_ready",e.SOCKET_DISCONNECTED="socket_disconnected",e.SOCKET_RECONNECT="socket_reconnect",e.OTP="otp",e.SDK_RPC_CALL="sdk_rpc_call",e.AUTHORIZED="authorized",e.CONNECTION_STATUS="connection_status",e.MESSAGE="message",e.TERMINATE="terminate"}($||($={})),function(e){e.KEY_EXCHANGE="key_exchange"}(L||(L={})),function(e){e.KEY_HANDSHAKE_START="key_handshake_start",e.KEY_HANDSHAKE_CHECK="key_handshake_check",e.KEY_HANDSHAKE_SYN="key_handshake_SYN",e.KEY_HANDSHAKE_SYNACK="key_handshake_SYNACK",e.KEY_HANDSHAKE_ACK="key_handshake_ACK",e.KEY_HANDSHAKE_NONE="none"}(M||(M={}));class H extends s{constructor({communicationLayer:e,otherPublicKey:t,context:n,ecies:o,logging:i}){super(),this.keysExchanged=!1,this.step=M.KEY_HANDSHAKE_NONE,this.debug=!1,this.context=n,this.myECIES=new N(Object.assign(Object.assign({},o),{debug:null==i?void 0:i.eciesLayer})),this.communicationLayer=e,this.myPublicKey=this.myECIES.getPublicKey(),this.debug=!0===(null==i?void 0:i.keyExchangeLayer),(null==i?void 0:i.keyExchangeLayer)&&v.enable("KeyExchange:Layer"),t&&this.setOtherPublicKey(t),this.communicationLayer.on(L.KEY_EXCHANGE,this.onKeyExchangeMessage.bind(this))}onKeyExchangeMessage(e){f.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} keysExchanged=${this.keysExchanged}`,e);const{message:t}=e;this.keysExchanged&&f.KeyExchange(`[KeyExchange: onKeyExchangeMessage()] context=${this.context} received handshake while already exchanged. step=${this.step} otherPubKey=${this.otherPublicKey}`),this.emit($.KEY_INFO,t.type),t.type===M.KEY_HANDSHAKE_SYN?(this.checkStep([M.KEY_HANDSHAKE_NONE,M.KEY_HANDSHAKE_ACK]),f.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYN",t),t.pubkey&&this.setOtherPublicKey(t.pubkey),this.communicationLayer.sendMessage({type:M.KEY_HANDSHAKE_SYNACK,pubkey:this.myPublicKey}),this.setStep(M.KEY_HANDSHAKE_ACK)):t.type===M.KEY_HANDSHAKE_SYNACK?(this.checkStep([M.KEY_HANDSHAKE_SYNACK,M.KEY_HANDSHAKE_ACK,M.KEY_HANDSHAKE_NONE]),f.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_SYNACK"),t.pubkey&&this.setOtherPublicKey(t.pubkey),this.communicationLayer.sendMessage({type:M.KEY_HANDSHAKE_ACK}),this.keysExchanged=!0,this.setStep(M.KEY_HANDSHAKE_ACK),this.emit($.KEYS_EXCHANGED)):t.type===M.KEY_HANDSHAKE_ACK&&(f.KeyExchange("[KeyExchange: onKeyExchangeMessage()] KEY_HANDSHAKE_ACK set keysExchanged to true!"),this.checkStep([M.KEY_HANDSHAKE_ACK,M.KEY_HANDSHAKE_NONE]),this.keysExchanged=!0,this.setStep(M.KEY_HANDSHAKE_ACK),this.emit($.KEYS_EXCHANGED))}resetKeys(e){this.clean(),this.myECIES=new N(e)}clean(){f.KeyExchange(`[KeyExchange: clean()] context=${this.context} reset handshake state`),this.setStep(M.KEY_HANDSHAKE_NONE),this.emit($.KEY_INFO,this.step),this.keysExchanged=!1}start({isOriginator:e,force:t}){f.KeyExchange(`[KeyExchange: start()] context=${this.context} isOriginator=${e} step=${this.step} force=${t} keysExchanged=${this.keysExchanged}`),e?!(this.keysExchanged||this.step!==M.KEY_HANDSHAKE_NONE&&this.step!==M.KEY_HANDSHAKE_SYNACK)||t?(f.KeyExchange(`[KeyExchange: start()] context=${this.context} -- start key exchange (force=${t}) -- step=${this.step}`,this.step),this.clean(),this.setStep(M.KEY_HANDSHAKE_SYNACK),this.communicationLayer.sendMessage({type:M.KEY_HANDSHAKE_SYN,pubkey:this.myPublicKey})):f.KeyExchange(`[KeyExchange: start()] context=${this.context} -- key exchange already ${this.keysExchanged?"done":"in progress"} -- aborted.`,this.step):this.keysExchanged&&!0!==t?f.KeyExchange("[KeyExchange: start()] don't send KEY_HANDSHAKE_START -- exchange already done."):(this.communicationLayer.sendMessage({type:M.KEY_HANDSHAKE_START}),this.clean())}setStep(e){this.step=e,this.emit($.KEY_INFO,e)}checkStep(e){e.length>0&&-1===e.indexOf(this.step.toString())&&console.warn(`[KeyExchange: checkStep()]  Wrong Step "${this.step}" not within ${e}`)}setKeysExchanged(e){this.keysExchanged=e}areKeysExchanged(){return this.keysExchanged}getMyPublicKey(){return this.myPublicKey}getOtherPublicKey(){return this.otherPublicKey}setOtherPublicKey(e){f.KeyExchange("[KeyExchange: setOtherPubKey()]",e),this.otherPublicKey=e}encryptMessage(e){if(!this.otherPublicKey)throw new Error("encryptMessage: Keys not exchanged - missing otherPubKey");return this.myECIES.encrypt(e,this.otherPublicKey)}decryptMessage(e){if(!this.otherPublicKey)throw new Error("decryptMessage: Keys not exchanged - missing otherPubKey");return this.myECIES.decrypt(e)}getKeyInfo(){return{ecies:Object.assign(Object.assign({},this.myECIES.getKeyInfo()),{otherPubKey:this.otherPublicKey}),step:this.step,keysExchanged:this.areKeysExchanged()}}toString(){const e={keyInfo:this.getKeyInfo(),keysExchanged:this.keysExchanged,step:this.step};return JSON.stringify(e)}}!function(e){e.TERMINATE="terminate",e.ANSWER="answer",e.OFFER="offer",e.CANDIDATE="candidate",e.JSONRPC="jsonrpc",e.WALLET_INFO="wallet_info",e.ORIGINATOR_INFO="originator_info",e.PAUSE="pause",e.OTP="otp",e.AUTHORIZED="authorized",e.PING="ping",e.READY="ready"}(P||(P={}));const F=e=>new Promise((t=>{setTimeout(t,e)})),U=(e,t,n=200)=>l(void 0,void 0,void 0,(function*(){let o;const i=Date.now();let s=!1;for(;!s;){if(s=Date.now()-i>3e5,o=t[e],void 0!==o.elapsedTime)return o;yield F(n)}throw new Error(`RPC ${e} timed out`)})),Y=({rpcId:e,instance:t})=>l(void 0,void 0,void 0,(function*(){for(;t.state.lastRpcId===e||void 0===t.state.lastRpcId;)yield F(200);return t.state.lastRpcId})),j=e=>l(void 0,void 0,void 0,(function*(){var t,n,o,i,s;return f.SocketService(`[SocketService: reconnectSocket()] instance.state.socket?.connected=${null===(t=e.state.socket)||void 0===t?void 0:t.connected} trying to reconnect after socketio disconnection`,e),yield F(200),(null===(n=e.state.socket)||void 0===n?void 0:n.connected)||(e.state.resumed=!0,null===(o=e.state.socket)||void 0===o||o.connect(),e.emit($.SOCKET_RECONNECT),null===(i=e.state.socket)||void 0===i||i.emit($.JOIN_CHANNEL,e.state.channelId,`${e.state.context}connect_again`)),yield F(100),null===(s=e.state.socket)||void 0===s?void 0:s.connected}));function z(e){return t=>{f.SocketService(`[SocketService: handleDisconnect()] on 'disconnect' manualDisconnect=${e.state.manualDisconnect}`,t),e.state.manualDisconnect||(e.emit($.SOCKET_DISCONNECTED),function(e){"undefined"!=typeof window&&"undefined"!=typeof document&&(f.SocketService(`[SocketService: checkFocusAndReconnect()] hasFocus=${document.hasFocus()}`,e),document.hasFocus()?j(e).then((t=>{f.SocketService(`SocketService::checkFocus reconnectSocket success=${t}`,e)})).catch((e=>{console.error("SocketService::checkFocus Error reconnecting socket",e)})):window.addEventListener("focus",(()=>{j(e).catch((e=>{console.error("SocketService::checkFocus Error reconnecting socket",e)}))}),{once:!0}))}(e))}}var G;!function(e){e.REQUEST="sdk_connect_request_started",e.REQUEST_MOBILE="sdk_connect_request_started_mobile",e.RECONNECT="sdk_reconnect_request_started",e.CONNECTED="sdk_connection_established",e.CONNECTED_MOBILE="sdk_connection_established_mobile",e.AUTHORIZED="sdk_connection_authorized",e.REJECTED="sdk_connection_rejected",e.TERMINATED="sdk_connection_terminated",e.DISCONNECTED="sdk_disconnected",e.SDK_USE_EXTENSION="sdk_use_extension",e.SDK_RPC_REQUEST="sdk_rpc_request",e.SDK_RPC_REQUEST_RECEIVED="sdk_rpc_request_received",e.SDK_RPC_REQUEST_DONE="sdk_rpc_request_done",e.SDK_EXTENSION_UTILIZED="sdk_extension_utilized",e.SDK_USE_INAPP_BROWSER="sdk_use_inapp_browser"}(G||(G={}));const V="SDK_CONNECTION_ISSUE";var W;!function(e){e.RPC_CHECK="rpcCheck",e.SKIPPED_RPC="skippedRpc"}(W||(W={}));const J=["eth_sendTransaction","eth_signTypedData","eth_signTransaction","personal_sign","wallet_requestPermissions","wallet_switchEthereumChain","eth_signTypedData_v3","eth_signTypedData_v4","metamask_connectSign","metamask_connectWith","metamask_batch"].map((e=>e.toLowerCase()));function B(e,t){var n,o,i,s;if(!e.state.channelId)throw new Error("Create a channel first");f.SocketService(`[SocketService: handleSendMessage()] context=${e.state.context} areKeysExchanged=${null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged()}`,t);(null===(o=null==t?void 0:t.type)||void 0===o?void 0:o.startsWith("key_handshake"))?function(e,t){var n;f.SocketService(`[SocketService: handleKeyHandshake()] context=${e.state.context}`,t),null===(n=e.state.socket)||void 0===n||n.emit($.MESSAGE,{id:e.state.channelId,context:e.state.context,message:t})}(e,t):(!function(e,t){var n;if(!(null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged()))throw f.SocketService(`[SocketService: validateKeyExchange()] context=${e.state.context} ERROR keys not exchanged`,t),new Error("Keys not exchanged BBB")}(e,t),function(e,t){var n;const o=null!==(n=null==t?void 0:t.method)&&void 0!==n?n:"",i=null==t?void 0:t.id;e.state.isOriginator&&i&&(e.state.rpcMethodTracker[i]={id:i,timestamp:Date.now(),method:o},e.emit($.RPC_UPDATE,e.state.rpcMethodTracker[i]))}(e,t),function(e,t){var n,o;const i=null===(n=e.state.keyExchange)||void 0===n?void 0:n.encryptMessage(JSON.stringify(t)),s={id:e.state.channelId,context:e.state.context,message:i,plaintext:e.state.hasPlaintext?JSON.stringify(t):void 0};f.SocketService(`[SocketService: encryptAndSendMessage()] context=${e.state.context}`,s),t.type===P.TERMINATE&&(e.state.manualDisconnect=!0),null===(o=e.state.socket)||void 0===o||o.emit($.MESSAGE,s)}(e,t),e.remote.state.analytics&&e.remote.state.isOriginator&&t.method&&J.includes(t.method.toLowerCase())&&K({id:null!==(i=e.remote.state.channelId)&&void 0!==i?i:"",event:G.SDK_RPC_REQUEST,sdkVersion:e.remote.state.sdkVersion,commLayerVersion:A.version,walletVersion:null===(s=e.remote.state.walletInfo)||void 0===s?void 0:s.version,params:{method:t.method,from:"mobile"}},e.remote.state.communicationServerUrl).catch((e=>{console.error("Cannot send analytics",e)})),function(e,t){var n;return l(this,void 0,void 0,(function*(){const o=null==t?void 0:t.id,i=null!==(n=null==t?void 0:t.method)&&void 0!==n?n:"";if(e.state.isOriginator&&o)try{const n=U(o,e.state.rpcMethodTracker,200).then((e=>({type:W.RPC_CHECK,result:e}))),s=(()=>l(this,void 0,void 0,(function*(){const t=yield Y({instance:e,rpcId:o}),n=yield U(t,e.state.rpcMethodTracker,200);return{type:W.SKIPPED_RPC,result:n}})))(),a=yield Promise.race([n,s]);if(a.type===W.RPC_CHECK){const e=a.result;f.SocketService(`[SocketService:handleRpcReplies()] id=${t.id} ${i} ( ${e.elapsedTime} ms)`,e.result)}else{if(a.type!==W.SKIPPED_RPC)throw new Error(`Error handling RPC replies for ${o}`);{const{result:t}=a;console.warn(`[SocketService handleRpcReplies()] RPC METHOD HAS BEEN SKIPPED rpcid=${o} method=${i}`,t);const n=Object.assign(Object.assign({},e.state.rpcMethodTracker[o]),{error:new Error(V)});e.emit($.RPC_UPDATE,n);const s={data:Object.assign(Object.assign({},n),{jsonrpc:"2.0"}),name:"metamask-provider"};e.emit($.MESSAGE,{message:s})}}}catch(e){throw console.warn(`[SocketService handleRpcReplies()] Error rpcId=${t.id} ${i}`,e),e}}))}(e,t).catch((e=>{console.warn("Error handleRpcReplies",e)})))}const Z=[{event:"clients_connected",handler:function(e,t){return n=>l(this,void 0,void 0,(function*(){var n,o,i,s,a,c,r,l;f.SocketService(`[SocketService: handleClientsConnected()] context=${e.state.context} on 'clients_connected-${t}'  resumed=${e.state.resumed}  clientsPaused=${e.state.clientsPaused} keysExchanged=${null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged()} isOriginator=${e.state.isOriginator}`),e.emit($.CLIENTS_CONNECTED,{isOriginator:e.state.isOriginator,keysExchanged:null===(o=e.state.keyExchange)||void 0===o?void 0:o.areKeysExchanged(),context:e.state.context}),e.state.resumed?(e.state.isOriginator||(f.SocketService(`[SocketService: handleClientsConnected()] context=${e.state.context} 'clients_connected' / keysExchanged=${null===(i=e.state.keyExchange)||void 0===i?void 0:i.areKeysExchanged()} -- backward compatibility`),null===(s=e.state.keyExchange)||void 0===s||s.start({isOriginator:null!==(a=e.state.isOriginator)&&void 0!==a&&a})),e.state.resumed=!1):e.state.clientsPaused?f.SocketService("[SocketService: handleClientsConnected()] 'clients_connected' skip sending originatorInfo on pause"):e.state.isOriginator||(f.SocketService(`[SocketService: handleClientsConnected()] context=${e.state.context} on 'clients_connected' / keysExchanged=${null===(c=e.state.keyExchange)||void 0===c?void 0:c.areKeysExchanged()} -- backward compatibility`),null===(r=e.state.keyExchange)||void 0===r||r.start({isOriginator:null!==(l=e.state.isOriginator)&&void 0!==l&&l,force:!0})),e.state.clientsConnected=!0,e.state.clientsPaused=!1}))}},{event:"channel_created",handler:function(e,t){return n=>{f.SocketService(`[SocketService: handleChannelCreated()] context=${e.state.context} on 'channel_created-${t}'`,n),e.emit($.CHANNEL_CREATED,n)}}},{event:"clients_disconnected",handler:function(e,t){return()=>{var n;e.state.clientsConnected=!1,f.SocketService(`[SocketService: handlesClientsDisconnected()] context=${e.state.context} on 'clients_disconnected-${t}'`),e.state.isOriginator&&!e.state.clientsPaused&&(null===(n=e.state.keyExchange)||void 0===n||n.clean()),e.emit($.CLIENTS_DISCONNECTED,t)}}},{event:"message",handler:function(e,t){return({id:n,message:o,error:i})=>{var s,a,c,r,l,d,u,h,m,g,E,v,y,C,p,S,k;if(f.SocketService(`[SocketService handleMessage()] context=${e.state.context} on 'message' ${t} keysExchanged=${null===(s=e.state.keyExchange)||void 0===s?void 0:s.areKeysExchanged()}`,o),i)throw f.SocketService(`\n      [SocketService handleMessage()] context=${e.state.context}::on 'message' error=${i}`),new Error(i);try{!function(e,t){if(t!==e.channelId)throw e.debug&&console.error(`Wrong id ${t} - should be ${e.channelId}`),new Error("Wrong id")}(e.state,n)}catch(e){return void console.error("ignore message --- wrong id ",o)}if(e.state.isOriginator&&(null==o?void 0:o.type)===M.KEY_HANDSHAKE_START)return f.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' received HANDSHAKE_START isOriginator=${e.state.isOriginator}`,o),void(null===(a=e.state.keyExchange)||void 0===a||a.start({isOriginator:null!==(c=e.state.isOriginator)&&void 0!==c&&c,force:!0}));if((null==o?void 0:o.type)===P.PING)return f.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' ping `),void e.emit($.MESSAGE,{message:{type:"ping"}});if(f.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' originator=${e.state.isOriginator}, type=${null==o?void 0:o.type}, keysExchanged=${null===(r=e.state.keyExchange)||void 0===r?void 0:r.areKeysExchanged()}`),null===(l=null==o?void 0:o.type)||void 0===l?void 0:l.startsWith("key_handshake"))return f.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' emit KEY_EXCHANGE`,o),void e.emit(L.KEY_EXCHANGE,{message:o,context:e.state.context});if(null===(d=e.state.keyExchange)||void 0===d?void 0:d.areKeysExchanged()){if(-1!==o.toString().indexOf("type"))return console.warn("[SocketService handleMessage() ::on 'message' received non encrypted unkwown message"),void e.emit($.MESSAGE,o)}else{let t=!1;try{null===(u=e.state.keyExchange)||void 0===u||u.decryptMessage(o),t=!0}catch(e){}if(!t)return e.state.isOriginator?null===(m=e.state.keyExchange)||void 0===m||m.start({isOriginator:null!==(g=e.state.isOriginator)&&void 0!==g&&g}):e.sendMessage({type:M.KEY_HANDSHAKE_START}),void console.warn(`Message ignored because invalid key exchange status. step=${null===(E=e.state.keyExchange)||void 0===E?void 0:E.getKeyInfo().step}`,null===(v=e.state.keyExchange)||void 0===v?void 0:v.getKeyInfo(),o);console.warn("Invalid key exchange status detected --- updating it."),null===(h=e.state.keyExchange)||void 0===h||h.setKeysExchanged(!0)}const x=null===(y=e.state.keyExchange)||void 0===y?void 0:y.decryptMessage(o),_=JSON.parse(null!=x?x:"{}");if((null==_?void 0:_.type)===P.PAUSE?e.state.clientsPaused=!0:e.state.clientsPaused=!1,e.state.isOriginator&&_.data){const t=_.data,n=e.state.rpcMethodTracker[t.id];if(n){const o=Date.now()-n.timestamp;f.SocketService(`[SocketService handleMessage()] context=${e.state.context}::on 'message' received answer for id=${t.id} method=${n.method} responseTime=${o}`,_),e.remote.state.analytics&&J.includes(n.method.toLowerCase())&&K({id:null!==(C=e.remote.state.channelId)&&void 0!==C?C:"",event:G.SDK_RPC_REQUEST_DONE,sdkVersion:e.remote.state.sdkVersion,commLayerVersion:A.version,walletVersion:null===(p=e.remote.state.walletInfo)||void 0===p?void 0:p.version,params:{method:n.method,from:"mobile"}},e.remote.state.communicationServerUrl).catch((e=>{console.error("Cannot send analytics",e)}));const i=Object.assign(Object.assign({},n),{result:t.result,error:t.error?{code:null===(S=t.error)||void 0===S?void 0:S.code,message:null===(k=t.error)||void 0===k?void 0:k.message}:void 0,elapsedTime:o});e.state.rpcMethodTracker[t.id]=i,e.emit($.RPC_UPDATE,i)}}e.emit($.MESSAGE,{message:_})}}},{event:"clients_waiting_to_join",handler:function(e,t){return n=>{f.SocketService(`[SocketService: handleClientsWaitingToJoin()] context=${e.state.context} on 'clients_waiting_to_join-${t}'`,n),e.emit($.CLIENTS_WAITING,n)}}}],X=[{event:$.KEY_INFO,handler:function(e){return t=>{f.SocketService("[SocketService: handleKeyInfo()] on 'KEY_INFO'",t),e.emit($.KEY_INFO,t)}}},{event:$.KEYS_EXCHANGED,handler:function(e){return()=>{var t,n;f.SocketService(`[SocketService: handleKeysExchanged()] on 'keys_exchanged' keyschanged=${null===(t=e.state.keyExchange)||void 0===t?void 0:t.areKeysExchanged()}`),e.emit($.KEYS_EXCHANGED,{keysExchanged:null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged(),isOriginator:e.state.isOriginator});const o={keyInfo:e.getKeyInfo()};e.emit($.SERVICE_STATUS,o)}}}];function Q(e,t){f.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} setting socket listeners for channel ${t}...`);const{socket:n}=e.state,{keyExchange:o}=e.state;e.state.setupChannelListeners&&console.warn(`[SocketService: setupChannelListener()] context=${e.state.context} socket listeners already set up for channel ${t}`),n&&e.state.isOriginator&&(e.state.debug&&(null==n||n.io.on("error",(t=>{f.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} socket event=error`,t)})),null==n||n.io.on("reconnect",(t=>{f.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} socket event=reconnect`,t)})),null==n||n.io.on("reconnect_error",(t=>{f.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} socket event=reconnect_error`,t)})),null==n||n.io.on("reconnect_failed",(()=>{f.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} socket event=reconnect_failed`)})),null==n||n.io.on("ping",(()=>{f.SocketService(`[SocketService: setupChannelListener()] context=${e.state.context} socket event=ping`)}))),null==n||n.on("disconnect",(t=>(f.SocketService(`[SocketService: setupChannelListener()] on 'disconnect' -- MetaMaskSDK socket disconnected '${t}' begin recovery...`),z(e)(t))))),Z.forEach((({event:o,handler:i})=>{const s=`${o}-${t}`;null==n||n.on(s,i(e,t))})),X.forEach((({event:t,handler:n})=>{null==o||o.on(t,n(e))})),e.state.setupChannelListeners=!0}class q extends s{constructor({otherPublicKey:e,reconnect:t,communicationLayerPreference:n,transports:o,communicationServerUrl:i,context:s,ecies:a,remote:c,logging:l}){super(),this.state={clientsConnected:!1,clientsPaused:!1,manualDisconnect:!1,lastRpcId:void 0,rpcMethodTracker:{},hasPlaintext:!1,communicationServerUrl:""},this.state.resumed=t,this.state.context=s,this.state.communicationLayerPreference=n,this.state.debug=!0===(null==l?void 0:l.serviceLayer),this.remote=c,!0===(null==l?void 0:l.serviceLayer)&&v.enable("SocketService:Layer"),this.state.communicationServerUrl=i,this.state.hasPlaintext=this.state.communicationServerUrl!==O&&!0===(null==l?void 0:l.plaintext);const d={autoConnect:!1,transports:R,withCredentials:!0};o&&(d.transports=o),f.SocketService(`[SocketService: constructor()] Socket IO url: ${this.state.communicationServerUrl}`),this.state.socket=r(i,d);const u={communicationLayer:this,otherPublicKey:e,sendPublicKey:!1,context:this.state.context,ecies:a,logging:l};this.state.keyExchange=new H(u)}resetKeys(){return e=this,f.SocketService("[SocketService: resetKeys()] Resetting keys."),void(null===(t=e.state.keyExchange)||void 0===t||t.resetKeys());var e,t}createChannel(){return function(e){var t,n,o,i;f.SocketService(`[SocketService: createChannel()] context=${e.state.context}`),(null===(t=e.state.socket)||void 0===t?void 0:t.connected)||null===(n=e.state.socket)||void 0===n||n.connect(),e.state.manualDisconnect=!1,e.state.isOriginator=!0;const s=c();return e.state.channelId=s,Q(e,s),null===(o=e.state.socket)||void 0===o||o.emit($.JOIN_CHANNEL,s,`${e.state.context}createChannel`),{channelId:s,pubKey:(null===(i=e.state.keyExchange)||void 0===i?void 0:i.getMyPublicKey())||""}}(this)}connectToChannel({channelId:e,isOriginator:t=!1,withKeyExchange:n=!1}){return function({options:e,instance:t}){var n,o,i,s;const{channelId:a,withKeyExchange:c,isOriginator:r}=e;if(f.SocketService(`[SocketService: connectToChannel()] context=${t.state.context} channelId=${a} isOriginator=${r}`,null===(n=t.state.keyExchange)||void 0===n?void 0:n.toString()),null===(o=t.state.socket)||void 0===o?void 0:o.connected)throw new Error("socket already connected");t.state.manualDisconnect=!1,null===(i=t.state.socket)||void 0===i||i.connect(),t.state.withKeyExchange=c,t.state.isOriginator=r,t.state.channelId=a,Q(t,a),null===(s=t.state.socket)||void 0===s||s.emit($.JOIN_CHANNEL,a,`${t.state.context}_connectToChannel`)}({options:{channelId:e,isOriginator:t,withKeyExchange:n},instance:this})}getKeyInfo(){return this.state.keyExchange.getKeyInfo()}keyCheck(){var e,t;null===(t=(e=this).state.socket)||void 0===t||t.emit($.MESSAGE,{id:e.state.channelId,context:e.state.context,message:{type:M.KEY_HANDSHAKE_CHECK,pubkey:e.getKeyInfo().ecies.otherPubKey}})}getKeyExchange(){return this.state.keyExchange}sendMessage(e){return B(this,e)}ping(){return e=this,f.SocketService(`[SocketService: ping()] context=${e.state.context} originator=${e.state.isOriginator} keysExchanged=${null===(t=e.state.keyExchange)||void 0===t?void 0:t.areKeysExchanged()}`),e.state.isOriginator&&((null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged())?(console.warn(`[SocketService:ping()] context=${e.state.context} sending READY message`),e.sendMessage({type:P.READY})):(console.warn(`[SocketService: ping()] context=${e.state.context} starting key exchange`),null===(o=e.state.keyExchange)||void 0===o||o.start({isOriginator:null!==(i=e.state.isOriginator)&&void 0!==i&&i}))),void(null===(s=e.state.socket)||void 0===s||s.emit($.MESSAGE,{id:e.state.channelId,context:e.state.context,message:{type:P.PING}}));var e,t,n,o,i,s}pause(){return e=this,f.SocketService(`[SocketService: pause()] context=${e.state.context}`),e.state.manualDisconnect=!0,(null===(t=e.state.keyExchange)||void 0===t?void 0:t.areKeysExchanged())&&e.sendMessage({type:P.PAUSE}),void(null===(n=e.state.socket)||void 0===n||n.disconnect());var e,t,n}isConnected(){var e;return null===(e=this.state.socket)||void 0===e?void 0:e.connected}resume(){return e=this,f.SocketService(`[SocketService: resume()] context=${e.state.context} connected=${null===(t=e.state.socket)||void 0===t?void 0:t.connected} manualDisconnect=${e.state.manualDisconnect} resumed=${e.state.resumed} keysExchanged=${null===(n=e.state.keyExchange)||void 0===n?void 0:n.areKeysExchanged()}`),(null===(o=e.state.socket)||void 0===o?void 0:o.connected)?f.SocketService("[SocketService: resume()] already connected."):(null===(i=e.state.socket)||void 0===i||i.connect(),f.SocketService(`[SocketService: resume()] after connecting socket --\x3e connected=${null===(s=e.state.socket)||void 0===s?void 0:s.connected}`),null===(a=e.state.socket)||void 0===a||a.emit($.JOIN_CHANNEL,e.state.channelId,`${e.state.context}_resume`)),(null===(c=e.state.keyExchange)||void 0===c?void 0:c.areKeysExchanged())?e.state.isOriginator||e.sendMessage({type:P.READY}):e.state.isOriginator||null===(r=e.state.keyExchange)||void 0===r||r.start({isOriginator:null!==(l=e.state.isOriginator)&&void 0!==l&&l}),e.state.manualDisconnect=!1,void(e.state.resumed=!0);var e,t,n,o,i,s,a,c,r,l}getRPCMethodTracker(){return this.state.rpcMethodTracker}disconnect(e){return function(e,t){var n,o;f.SocketService(`[SocketService: disconnect()] context=${e.state.context}`,t),(null==t?void 0:t.terminate)&&(e.state.channelId=t.channelId,null===(n=e.state.keyExchange)||void 0===n||n.clean()),e.state.rpcMethodTracker={},e.state.manualDisconnect=!0,null===(o=e.state.socket)||void 0===o||o.disconnect()}(this,e)}}var ee,te,ne;function oe(e){return()=>l(this,void 0,void 0,(function*(){var t,n,o;const{state:i}=e;if(i.authorized)return;yield(()=>l(this,void 0,void 0,(function*(){for(;!i.walletInfo;)yield F(500)})))();const s="7.3".localeCompare((null===(t=i.walletInfo)||void 0===t?void 0:t.version)||"");if(f.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' version=${null===(n=i.walletInfo)||void 0===n?void 0:n.version} compareValue=${s}`),1!==s)return;const a=i.platformType===te.MobileWeb||i.platformType===te.ReactNative||i.platformType===te.MetaMaskMobileWebview;f.RemoteCommunication(`[RemoteCommunication: handleAuthorizedEvent()] HACK 'authorized' platform=${i.platformType} secure=${a} channel=${i.channelId} walletVersion=${null===(o=i.walletInfo)||void 0===o?void 0:o.version}`),a&&(i.authorized=!0,e.emit($.AUTHORIZED))}))}function ie(e){return t=>{const{state:n}=e;f.RemoteCommunication(`[RemoteCommunication: handleChannelCreatedEvent()] context=${n.context} on 'channel_created' channelId=${t}`),e.emit($.CHANNEL_CREATED,t)}}function se(e,t){return()=>{var n,o,i,s;const{state:a}=e;if(f.RemoteCommunication(`[RemoteCommunication: handleClientsConnectedEvent()] on 'clients_connected' channel=${a.channelId} keysExchanged=${null===(o=null===(n=a.communicationLayer)||void 0===n?void 0:n.getKeyInfo())||void 0===o?void 0:o.keysExchanged}`),a.analytics){const e=a.isOriginator?G.REQUEST:G.REQUEST_MOBILE;K(Object.assign(Object.assign({id:null!==(i=a.channelId)&&void 0!==i?i:"",event:a.reconnection?G.RECONNECT:e},a.originatorInfo),{commLayer:t,sdkVersion:a.sdkVersion,walletVersion:null===(s=a.walletInfo)||void 0===s?void 0:s.version,commLayerVersion:A.version}),a.communicationServerUrl).catch((e=>{console.error("Cannot send analytics",e)}))}a.clientsConnected=!0,a.originatorInfoSent=!1,e.emit($.CLIENTS_CONNECTED)}}function ae(e,t){return n=>{var o;const{state:i}=e;f.RemoteCommunication(`[RemoteCommunication: handleClientsDisconnectedEvent()] context=${i.context} on 'clients_disconnected' channelId=${n}`),i.clientsConnected=!1,e.emit($.CLIENTS_DISCONNECTED,i.channelId),e.setConnectionStatus(D.DISCONNECTED),i.ready=!1,i.authorized=!1,i.analytics&&i.channelId&&K({id:i.channelId,event:G.DISCONNECTED,sdkVersion:i.sdkVersion,commLayer:t,commLayerVersion:A.version,walletVersion:null===(o=i.walletInfo)||void 0===o?void 0:o.version},i.communicationServerUrl).catch((e=>{console.error("Cannot send analytics",e)}))}}function ce(e){return t=>{var n;const{state:o}=e;if(f.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] context=${o.context} on 'clients_waiting' numberUsers=${t} ready=${o.ready} autoStarted=${o.originatorConnectStarted}`),e.setConnectionStatus(D.WAITING),e.emit($.CLIENTS_WAITING,t),o.originatorConnectStarted){f.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] on 'clients_waiting' watch autoStarted=${o.originatorConnectStarted} timeout`,o.autoConnectOptions);const t=(null===(n=o.autoConnectOptions)||void 0===n?void 0:n.timeout)||3e3,i=setTimeout((()=>{f.RemoteCommunication(`[RemoteCommunication: handleClientsWaitingEvent()] setTimeout(${t}) terminate channelConfig`,o.autoConnectOptions),o.originatorConnectStarted=!1,o.ready||e.setConnectionStatus(D.TIMEOUT),clearTimeout(i)}),t)}}}function re(e,t){return n=>{var o,i,s,a,c;const{state:r}=e;f.RemoteCommunication(`[RemoteCommunication: handleKeysExchangedEvent()] context=${r.context} on commLayer.'keys_exchanged' channel=${r.channelId}`,n),(null===(i=null===(o=r.communicationLayer)||void 0===o?void 0:o.getKeyInfo())||void 0===i?void 0:i.keysExchanged)&&e.setConnectionStatus(D.LINKED),function(e,t){var n,o,i,s;const{state:a}=e;f.RemoteCommunication(`[RemoteCommunication: setLastActiveDate()] channel=${a.channelId}`,t);const c={channelId:null!==(n=a.channelId)&&void 0!==n?n:"",validUntil:null!==(i=null===(o=a.channelConfig)||void 0===o?void 0:o.validUntil)&&void 0!==i?i:0,lastActive:t.getTime()};null===(s=a.storageManager)||void 0===s||s.persistChannelConfig(c)}(e,new Date),r.analytics&&r.channelId&&K({id:r.channelId,event:n.isOriginator?G.CONNECTED:G.CONNECTED_MOBILE,sdkVersion:r.sdkVersion,commLayer:t,commLayerVersion:A.version,walletVersion:null===(s=r.walletInfo)||void 0===s?void 0:s.version},r.communicationServerUrl).catch((e=>{console.error("Cannot send analytics",e)})),r.isOriginator=n.isOriginator,n.isOriginator||(null===(a=r.communicationLayer)||void 0===a||a.sendMessage({type:P.READY}),r.ready=!0,r.paused=!1),n.isOriginator&&!r.originatorInfoSent&&(null===(c=r.communicationLayer)||void 0===c||c.sendMessage({type:P.ORIGINATOR_INFO,originatorInfo:r.originatorInfo,originator:r.originatorInfo}),r.originatorInfoSent=!0)}}function le(e,t){const{state:n}=t;if(f.RemoteCommunication(`[RemoteCommunication: onCommunicationLayerMessage()] context=${n.context} on 'message' typeof=${typeof e}`,e),t.state.ready=!0,n.isOriginator||e.type!==P.ORIGINATOR_INFO)if(n.isOriginator&&e.type===P.WALLET_INFO)!function(e,t){const{state:n}=e;n.walletInfo=t.walletInfo,n.paused=!1}(t,e);else{if(e.type===P.TERMINATE)!function(e){const{state:t}=e;t.isOriginator&&(ge({options:{terminate:!0,sendMessage:!1},instance:e}),console.debug(),e.emit($.TERMINATE))}(t);else if(e.type===P.PAUSE)!function(e){const{state:t}=e;t.paused=!0,e.setConnectionStatus(D.PAUSED)}(t);else if(e.type===P.READY&&n.isOriginator)!function(e){const{state:t}=e;e.setConnectionStatus(D.LINKED);const n=t.paused;t.paused=!1,e.emit($.CLIENTS_READY,{isOriginator:t.isOriginator,walletInfo:t.walletInfo}),n&&(t.authorized=!0,e.emit($.AUTHORIZED))}(t);else{if(e.type===P.OTP&&n.isOriginator)return void function(e,t){var n;const{state:o}=e;e.emit($.OTP,t.otpAnswer),1==="6.6".localeCompare((null===(n=o.walletInfo)||void 0===n?void 0:n.version)||"")&&(console.warn("RemoteCommunication::on 'otp' -- backward compatibility <6.6 -- triger eth_requestAccounts"),e.emit($.SDK_RPC_CALL,{method:w.ETH_REQUESTACCOUNTS,params:[]}))}(t,e);e.type===P.AUTHORIZED&&n.isOriginator&&function(e){const{state:t}=e;t.authorized=!0,e.emit($.AUTHORIZED)}(t)}t.emit($.MESSAGE,e)}else!function(e,t){var n;const{state:o}=e;null===(n=o.communicationLayer)||void 0===n||n.sendMessage({type:P.WALLET_INFO,walletInfo:o.walletInfo}),o.originatorInfo=t.originatorInfo||t.originator,e.emit($.CLIENTS_READY,{isOriginator:o.isOriginator,originatorInfo:o.originatorInfo}),o.paused=!1}(t,e)}function de(e,t){var n,o;return l(this,void 0,void 0,(function*(){const{state:i}=e;f.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i.context} paused=${i.paused} ready=${i.ready} authorized=${i.authorized} socket=${null===(n=i.communicationLayer)||void 0===n?void 0:n.isConnected()} clientsConnected=${i.clientsConnected} status=${i._connectionStatus}`,t),!i.paused&&i.ready&&(null===(o=i.communicationLayer)||void 0===o?void 0:o.isConnected())&&i.clientsConnected||(f.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i.context}  SKIP message waiting for MM mobile readiness.`),yield new Promise((t=>{e.once($.CLIENTS_READY,t)})),f.RemoteCommunication(`[RemoteCommunication: sendMessage()] context=${i.context}  AFTER SKIP / READY -- sending pending message`));try{yield function(e,t){return l(this,void 0,void 0,(function*(){return new Promise((n=>{var o,i,s,a;const{state:c}=e;if(f.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${c.context} ready=${c.ready} authorized=${c.authorized} method=${t.method}`),1==="7.3".localeCompare((null===(o=c.walletInfo)||void 0===o?void 0:o.version)||""))return f.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] compatibility hack wallet version > ${null===(i=c.walletInfo)||void 0===i?void 0:i.version}`),null===(s=c.communicationLayer)||void 0===s||s.sendMessage(t),void n();!c.isOriginator||c.authorized?(null===(a=c.communicationLayer)||void 0===a||a.sendMessage(t),n()):e.once($.AUTHORIZED,(()=>{var e;f.RemoteCommunication(`[RemoteCommunication: handleAuthorization()] context=${c.context}  AFTER SKIP / AUTHORIZED -- sending pending message`),null===(e=c.communicationLayer)||void 0===e||e.sendMessage(t),n()}))}))}))}(e,t)}catch(e){throw console.error(`[RemoteCommunication: sendMessage()] context=${i.context}  ERROR`,e),e}}))}function ue(e){return t=>{let n=t;t.message&&(n=n.message),le(n,e)}}function he(e){return()=>{const{state:t}=e;f.RemoteCommunication("[RemoteCommunication: handleSocketReconnectEvent()] on 'socket_reconnect' -- reset key exchange status / set ready to false"),t.ready=!1,t.authorized=!1,b(t),e.emitServiceStatusEvent()}}function me(e){return()=>{const{state:t}=e;f.RemoteCommunication("[RemoteCommunication: handleSocketDisconnectedEvent()] on 'socket_Disconnected' set ready to false"),t.ready=!1}}function ge({options:e,instance:t}){var n,o,i,s,a,r;const{state:l}=t;f.RemoteCommunication(`[RemoteCommunication: disconnect()] channel=${l.channelId}`,e),l.ready=!1,l.paused=!1,(null==e?void 0:e.terminate)?(null===(n=l.storageManager)||void 0===n||n.terminate(null!==(o=l.channelId)&&void 0!==o?o:""),(null===(i=l.communicationLayer)||void 0===i?void 0:i.getKeyInfo().keysExchanged)&&(null==e?void 0:e.sendMessage)&&(null===(s=l.communicationLayer)||void 0===s||s.sendMessage({type:P.TERMINATE})),l.channelId=c(),e.channelId=l.channelId,l.channelConfig=void 0,l.originatorConnectStarted=!1,null===(a=l.communicationLayer)||void 0===a||a.disconnect(e),t.setConnectionStatus(D.TERMINATED)):(null===(r=l.communicationLayer)||void 0===r||r.disconnect(e),t.setConnectionStatus(D.DISCONNECTED))}!function(e){e.SOCKET="socket"}(ee||(ee={})),function(e){e.NonBrowser="nodejs",e.MetaMaskMobileWebview="in-app-browser",e.DesktopWeb="web-desktop",e.MobileWeb="web-mobile",e.ReactNative="react-native"}(te||(te={}));class Ee extends s{constructor({platformType:e,communicationLayerPreference:t,otherPublicKey:n,reconnect:o,walletInfo:i,dappMetadata:s,transports:a,context:c,ecies:r,analytics:l=!1,storage:d,sdkVersion:u,communicationServerUrl:h=O,logging:m,autoConnect:g={timeout:3e3}}){super(),this.state={ready:!1,authorized:!1,isOriginator:!1,paused:!1,platformType:"metamask-mobile",analytics:!1,reconnection:!1,originatorInfoSent:!1,communicationServerUrl:O,context:"",clientsConnected:!1,sessionDuration:T,originatorConnectStarted:!1,debug:!1,_connectionStatus:D.DISCONNECTED},this.state.otherPublicKey=n,this.state.dappMetadata=s,this.state.walletInfo=i,this.state.transports=a,this.state.platformType=e,this.state.analytics=l,this.state.isOriginator=!n,this.state.communicationServerUrl=h,this.state.context=c,this.state.sdkVersion=u,this.setMaxListeners(50),this.setConnectionStatus(D.DISCONNECTED),(null==d?void 0:d.duration)&&(this.state.sessionDuration=T),this.state.storageOptions=d,this.state.autoConnectOptions=g,this.state.debug=!0===(null==m?void 0:m.remoteLayer),!0===(null==m?void 0:m.remoteLayer)&&v.enable("RemoteCommunication:Layer"),this.state.logging=m,(null==d?void 0:d.storageManager)&&(this.state.storageManager=d.storageManager),this.initCommunicationLayer({communicationLayerPreference:t,otherPublicKey:n,reconnect:o,ecies:r,communicationServerUrl:h}),this.emitServiceStatusEvent()}initCommunicationLayer({communicationLayerPreference:e,otherPublicKey:t,reconnect:n,ecies:o,communicationServerUrl:i=O}){return function({communicationLayerPreference:e,otherPublicKey:t,reconnect:n,ecies:o,communicationServerUrl:i=O,instance:s}){var a,c,r,l,d,u,h,m,g;const{state:E}=s;if(e!==ee.SOCKET)throw new Error("Invalid communication protocol");E.communicationLayer=new q({communicationLayerPreference:e,otherPublicKey:t,reconnect:n,transports:E.transports,communicationServerUrl:i,context:E.context,ecies:o,logging:E.logging,remote:s});let v="undefined"!=typeof document&&document.URL||"",y="undefined"!=typeof document&&document.title||"";(null===(a=E.dappMetadata)||void 0===a?void 0:a.url)&&(v=E.dappMetadata.url),(null===(c=E.dappMetadata)||void 0===c?void 0:c.name)&&(y=E.dappMetadata.name);const C={url:v,title:y,source:null===(r=E.dappMetadata)||void 0===r?void 0:r.source,dappId:"undefined"==typeof window?null!==(h=null!==(d=null===(l=E.dappMetadata)||void 0===l?void 0:l.name)&&void 0!==d?d:null===(u=E.dappMetadata)||void 0===u?void 0:u.url)&&void 0!==h?h:"unkown":window.location.hostname,icon:(null===(m=E.dappMetadata)||void 0===m?void 0:m.iconUrl)||(null===(g=E.dappMetadata)||void 0===g?void 0:g.base64Icon),platform:E.platformType,apiVersion:A.version};E.originatorInfo=C;const p={[$.AUTHORIZED]:oe(s),[$.MESSAGE]:ue(s),[$.CLIENTS_CONNECTED]:se(s,e),[$.KEYS_EXCHANGED]:re(s,e),[$.SOCKET_DISCONNECTED]:me(s),[$.SOCKET_RECONNECT]:he(s),[$.CLIENTS_DISCONNECTED]:ae(s,e),[$.KEY_INFO]:()=>{s.emitServiceStatusEvent()},[$.CHANNEL_CREATED]:ie(s),[$.CLIENTS_WAITING]:ce(s),[$.RPC_UPDATE]:e=>{s.emit($.RPC_UPDATE,e)}};for(const[e,t]of Object.entries(p))try{E.communicationLayer.on(e,t)}catch(t){console.error(`Error registering handler for ${e}:`,t)}}({communicationLayerPreference:e,otherPublicKey:t,reconnect:n,ecies:o,communicationServerUrl:i,instance:this})}originatorSessionConnect(){return l(this,void 0,void 0,(function*(){return yield function(e){var t,n,o;return l(this,void 0,void 0,(function*(){const{state:i}=e;if(!i.storageManager)return void f.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] no storage manager defined - skip");const s=yield i.storageManager.getPersistedChannelConfig(null!==(t=i.channelId)&&void 0!==t?t:"");if(f.RemoteCommunication(`[RemoteCommunication: originatorSessionConnect()] autoStarted=${i.originatorConnectStarted} channelConfig`,s),null===(n=i.communicationLayer)||void 0===n?void 0:n.isConnected())return f.RemoteCommunication("[RemoteCommunication: originatorSessionConnect()] socket already connected - skip"),s;if(s){if(s.validUntil>Date.now())return i.channelConfig=s,i.originatorConnectStarted=!0,i.channelId=null==s?void 0:s.channelId,i.reconnection=!0,null===(o=i.communicationLayer)||void 0===o||o.connectToChannel({channelId:s.channelId,isOriginator:!0}),s;f.RemoteCommunication("[RemoteCommunication: autoConnect()] Session has expired")}i.originatorConnectStarted=!1}))}(this)}))}generateChannelIdConnect(){return l(this,void 0,void 0,(function*(){return function(e){var t,n,o,i,s;if(!e.communicationLayer)throw new Error("communication layer not initialized");if(e.ready)throw new Error("Channel already connected");if(e.channelId&&(null===(t=e.communicationLayer)||void 0===t?void 0:t.isConnected()))return console.warn("Channel already exists -- interrupt generateChannelId",e.channelConfig),e.channelConfig={channelId:e.channelId,validUntil:Date.now()+e.sessionDuration},null===(n=e.storageManager)||void 0===n||n.persistChannelConfig(e.channelConfig),{channelId:e.channelId,pubKey:null===(i=null===(o=e.communicationLayer)||void 0===o?void 0:o.getKeyInfo())||void 0===i?void 0:i.ecies.public};f.RemoteCommunication("[RemoteCommunication: generateChannelId()]"),b(e);const a=e.communicationLayer.createChannel();f.RemoteCommunication("[RemoteCommunication: generateChannelId()] channel created",a);const c={channelId:a.channelId,validUntil:Date.now()+e.sessionDuration};return e.channelId=a.channelId,e.channelConfig=c,null===(s=e.storageManager)||void 0===s||s.persistChannelConfig(c),{channelId:e.channelId,pubKey:a.pubKey}}(this.state)}))}clean(){return b(this.state)}connectToChannel(e,t){return function({channelId:e,withKeyExchange:t,state:n}){var o,i,s;if(!a(e))throw f.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${n.context} invalid channel channelId=${e}`),new Error(`Invalid channel ${e}`);if(f.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${n.context} channelId=${e}`),null===(o=n.communicationLayer)||void 0===o?void 0:o.isConnected())return void f.RemoteCommunication(`[RemoteCommunication: connectToChannel()] context=${n.context} already connected - interrupt connection.`);n.channelId=e,null===(i=n.communicationLayer)||void 0===i||i.connectToChannel({channelId:e,withKeyExchange:t});const c={channelId:e,validUntil:Date.now()+n.sessionDuration};n.channelConfig=c,null===(s=n.storageManager)||void 0===s||s.persistChannelConfig(c)}({channelId:e,withKeyExchange:t,state:this.state})}sendMessage(e){return de(this,e)}testStorage(){return l(this,void 0,void 0,(function*(){return function(e){var t,n;return l(this,void 0,void 0,(function*(){const o=yield null===(t=e.storageManager)||void 0===t?void 0:t.getPersistedChannelConfig(null!==(n=e.channelId)&&void 0!==n?n:"");f.RemoteCommunication("[RemoteCommunication: testStorage()] res",o)}))}(this.state)}))}getChannelConfig(){return this.state.channelConfig}isReady(){return this.state.ready}isConnected(){var e;return null===(e=this.state.communicationLayer)||void 0===e?void 0:e.isConnected()}isAuthorized(){return this.state.authorized}isPaused(){return this.state.paused}getCommunicationLayer(){return this.state.communicationLayer}ping(){var e;f.RemoteCommunication(`[RemoteCommunication: ping()] channel=${this.state.channelId}`),null===(e=this.state.communicationLayer)||void 0===e||e.ping()}keyCheck(){var e;f.RemoteCommunication(`[RemoteCommunication: keyCheck()] channel=${this.state.channelId}`),null===(e=this.state.communicationLayer)||void 0===e||e.keyCheck()}setConnectionStatus(e){this.state._connectionStatus!==e&&(this.state._connectionStatus=e,this.emit($.CONNECTION_STATUS,e),this.emitServiceStatusEvent())}emitServiceStatusEvent(){this.emit($.SERVICE_STATUS,this.getServiceStatus())}getConnectionStatus(){return this.state._connectionStatus}getServiceStatus(){return{originatorInfo:this.state.originatorInfo,keyInfo:this.getKeyInfo(),connectionStatus:this.state._connectionStatus,channelConfig:this.state.channelConfig,channelId:this.state.channelId}}getKeyInfo(){var e;return null===(e=this.state.communicationLayer)||void 0===e?void 0:e.getKeyInfo()}resetKeys(){var e;null===(e=this.state.communicationLayer)||void 0===e||e.resetKeys()}setOtherPublicKey(e){var t;const n=null===(t=this.state.communicationLayer)||void 0===t?void 0:t.getKeyExchange();if(!n)throw new Error("KeyExchange is not initialized.");n.getOtherPublicKey()!==e&&n.setOtherPublicKey(e)}pause(){var e;f.RemoteCommunication(`[RemoteCommunication: pause()] channel=${this.state.channelId}`),null===(e=this.state.communicationLayer)||void 0===e||e.pause(),this.setConnectionStatus(D.PAUSED)}getVersion(){return A.version}resume(){return function(e){var t;const{state:n}=e;f.RemoteCommunication(`[RemoteCommunication: resume()] channel=${n.channelId}`),null===(t=n.communicationLayer)||void 0===t||t.resume(),e.setConnectionStatus(D.LINKED)}(this)}getChannelId(){return this.state.channelId}getRPCMethodTracker(){var e;return null===(e=this.state.communicationLayer)||void 0===e?void 0:e.getRPCMethodTracker()}disconnect(e){return ge({options:e,instance:this})}}!function(e){e.RENEW="renew",e.LINK="link"}(ne||(ne={}));export{ne as AutoConnectType,ee as CommunicationLayerPreference,D as ConnectionStatus,O as DEFAULT_SERVER_URL,N as ECIES,$ as EventType,M as KeyExchangeMessageType,P as MessageType,te as PlatformType,Ee as RemoteCommunication,K as SendAnalytics,q as SocketService,G as TrackingEvents};
//# sourceMappingURL=metamask-sdk-communication-layer.js.map
