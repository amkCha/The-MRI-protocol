import { type EIP6963ProviderDetail, type Store as MipdStore } from 'mipd';
import { type Address, type Chain, type Client, type ClientConfig as viem_ClientConfig, type Transport as viem_Transport } from 'viem';
import { type Mutate, type StoreApi } from 'zustand/vanilla';
import { type ConnectorEventMap, type CreateConnectorFn } from './connectors/createConnector.js';
import { Emitter, type EventData } from './createEmitter.js';
import { type Storage } from './createStorage.js';
import type { Evaluate, ExactPartial, LooseOmit, OneOf } from './types/utils.js';
export type CreateConfigParameters<chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]], transports extends Record<chains[number]['id'], Transport> = Record<chains[number]['id'], Transport>> = Evaluate<{
    chains: chains;
    connectors?: CreateConnectorFn[] | undefined;
    multiInjectedProviderDiscovery?: boolean | undefined;
    storage?: Storage | null | undefined;
    ssr?: boolean | undefined;
    syncConnectedChain?: boolean | undefined;
} & OneOf<({
    transports: transports;
} & {
    [key in keyof ClientConfig]?: ClientConfig[key] | {
        [_ in chains[number]['id']]?: ClientConfig[key] | undefined;
    } | undefined;
}) | {
    client(parameters: {
        chain: chains[number];
    }): Client<transports[chains[number]['id']], chains[number]>;
}>>;
export declare function createConfig<const chains extends readonly [Chain, ...Chain[]], transports extends Record<chains[number]['id'], Transport>>(parameters: CreateConfigParameters<chains, transports>): Config<chains, transports>;
export type Config<chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]], transports extends Record<chains[number]['id'], Transport> = Record<chains[number]['id'], Transport>> = {
    readonly chains: chains;
    readonly connectors: readonly Connector[];
    readonly storage: Storage | null;
    readonly state: State<chains>;
    setState<tchains extends readonly [Chain, ...Chain[]] = chains>(value: State<tchains> | ((state: State<tchains>) => State<tchains>)): void;
    subscribe<state>(selector: (state: State<chains>) => state, listener: (state: state, previousState: state) => void, options?: {
        emitImmediately?: boolean | undefined;
        equalityFn?: ((a: state, b: state) => boolean) | undefined;
    } | undefined): () => void;
    getClient<chainId extends chains[number]['id']>(parameters?: {
        chainId?: chainId | chains[number]['id'] | undefined;
    }): Client<transports[chainId], Extract<chains[number], {
        id: chainId;
    }>>;
    /**
     * Not part of versioned API, proceed with caution.
     * @internal
     */
    _internal: {
        readonly mipd: MipdStore | undefined;
        readonly store: Mutate<StoreApi<any>, [['zustand/persist', any]]>;
        readonly ssr: boolean;
        readonly syncConnectedChain: boolean;
        readonly transports: transports;
        chains: {
            setState(value: readonly [Chain, ...Chain[]] | ((state: readonly [Chain, ...Chain[]]) => readonly [Chain, ...Chain[]])): void;
            subscribe(listener: (state: readonly [Chain, ...Chain[]], prevState: readonly [Chain, ...Chain[]]) => void): () => void;
        };
        connectors: {
            providerDetailToConnector(providerDetail: EIP6963ProviderDetail): CreateConnectorFn;
            setup(connectorFn: CreateConnectorFn): Connector;
            setState(value: Connector[] | ((state: Connector[]) => Connector[])): void;
            subscribe(listener: (state: Connector[], prevState: Connector[]) => void): () => void;
        };
        events: {
            change(data: EventData<ConnectorEventMap, 'change'>): void;
            connect(data: EventData<ConnectorEventMap, 'connect'>): void;
            disconnect(data: EventData<ConnectorEventMap, 'disconnect'>): void;
        };
    };
};
export type State<chains extends readonly [Chain, ...Chain[]] = readonly [Chain, ...Chain[]]> = {
    chainId: chains[number]['id'];
    connections: Map<string, Connection>;
    current: string | null;
    status: 'connected' | 'connecting' | 'disconnected' | 'reconnecting';
};
export type PartializedState = Evaluate<ExactPartial<Pick<State, 'chainId' | 'connections' | 'current' | 'status'>>>;
export type Connection = {
    accounts: readonly [Address, ...Address[]];
    chainId: number;
    connector: Connector;
};
export type Connector = ReturnType<CreateConnectorFn> & {
    emitter: Emitter<ConnectorEventMap>;
    uid: string;
};
export type Transport = (params: Parameters<viem_Transport>[0] & {
    connectors?: StoreApi<Connector[]>;
}) => ReturnType<viem_Transport>;
type ClientConfig = LooseOmit<viem_ClientConfig, 'account' | 'chain' | 'key' | 'name' | 'transport' | 'type'>;
export {};
//# sourceMappingURL=createConfig.d.ts.map