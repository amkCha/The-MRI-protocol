"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseDataMapper_1 = __importDefault(require("./BaseDataMapper"));
const AttestationRegistry_1 = require("../abi/AttestationRegistry");
const constants_1 = require("../utils/constants");
const simulationErrorHandler_1 = require("../utils/simulationErrorHandler");
const abiCoder_1 = require("../utils/abiCoder");
const transactionSender_1 = require("../utils/transactionSender");
const ipfsClient_1 = require("../utils/ipfsClient");
class AttestationDataMapper extends BaseDataMapper_1.default {
    constructor() {
        super(...arguments);
        this.typeName = "attestation";
        this.gqlInterface = `{
            id
            schemaId
            replacedBy
            attester
            portal
            attestedDate
            expirationDate
            revocationDate
            version
            revoked
            subject
            attestationData
            schemaString
            decodedData
  }`;
    }
    async findOneById(id) {
        const attestation = await super.findOneById(id);
        if (attestation !== undefined) {
            await this.enrichAttestation(attestation);
        }
        return attestation;
    }
    async findBy(first, skip, where, orderBy, orderDirection) {
        const attestations = await super.findBy(first, skip, where, orderBy, orderDirection);
        await Promise.all(attestations.map(async (attestation) => {
            await this.enrichAttestation(attestation);
        }));
        return attestations;
    }
    async enrichAttestation(attestation) {
        const schema = (await this.veraxSdk.schema.findOneById(attestation.schemaId));
        attestation.decodedPayload = (0, abiCoder_1.decodeWithRetry)(schema.schema, attestation.attestationData);
        attestation.attestedDate = Number(attestation.attestedDate);
        attestation.expirationDate = Number(attestation.expirationDate);
        attestation.revocationDate = Number(attestation.revocationDate);
        attestation.version = Number(attestation.version);
        // Check if data is stored offchain
        if (attestation.schemaId === constants_1.Constants.OFFCHAIN_DATA_SCHEMA_ID) {
            attestation.offchainData = {
                schemaId: attestation.decodedPayload[0].schemaId,
                uri: attestation.decodedPayload[0].uri,
            };
            attestation.decodedPayload = {};
            if (attestation.offchainData.uri.startsWith("ipfs://")) {
                try {
                    const ipfsHash = attestation.offchainData.uri.split("//")[1];
                    const response = await (0, ipfsClient_1.getIPFSContent)(ipfsHash);
                    if (response.toString().startsWith("0x")) {
                        const offchainDataSchema = (await this.veraxSdk.schema.findOneById(attestation.offchainData.schemaId));
                        attestation.decodedPayload = (0, abiCoder_1.decodeWithRetry)(offchainDataSchema.schema, attestation.attestationData);
                    }
                    else {
                        attestation.decodedPayload = response;
                    }
                }
                catch (error) {
                    attestation.offchainData.error = error.message;
                }
            }
        }
    }
    async getRelatedAttestations(id) {
        return this.findBy(undefined, undefined, {
            attestationData_contains: id,
            schemaId_in: [constants_1.Constants.RELATIONSHIP_SCHEMA_ID, constants_1.Constants.NAMED_GRAPH_RELATIONSHIP_SCHEMA_ID],
        }, undefined, undefined);
    }
    async simulateUpdateRouter(routerAddress) {
        return this.simulateContract("updateRouter", [routerAddress]);
    }
    async updateRouter(routerAddress, waitForConfirmation = false) {
        const request = await this.simulateUpdateRouter(routerAddress);
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async simulateMassImport(portalAddress, attestationPayloads) {
        const attestationPayloadsArg = [];
        for (const attestationPayload of attestationPayloads) {
            const matchingSchema = await this.veraxSdk.schema.findOneById(attestationPayload.schemaId);
            if (!matchingSchema) {
                throw new Error("No matching Schema");
            }
            const attestationData = (0, abiCoder_1.encode)(matchingSchema.schema, attestationPayload.attestationData);
            attestationPayloadsArg.push([
                attestationPayload.schemaId,
                attestationPayload.expirationDate,
                attestationPayload.subject,
                attestationData,
            ]);
        }
        return this.simulateContract("massImport", [attestationPayloadsArg, portalAddress]);
    }
    async massImport(portalAddress, attestationPayloads, waitForConfirmation = false) {
        const request = await this.simulateMassImport(portalAddress, attestationPayloads);
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async simulateIncrementVersionNumber() {
        return this.simulateContract("incrementVersionNumber", []);
    }
    async incrementVersionNumber(waitForConfirmation = false) {
        const request = await this.simulateIncrementVersionNumber();
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async isRegistered(attestationId) {
        return this.executeReadMethod("isRegistered", [attestationId]);
    }
    async isRevocable(portalId) {
        return this.executeReadMethod("isRevocable", [portalId]);
    }
    async getAttestation(attestationId) {
        return this.executeReadMethod("getAttestation", [attestationId]);
    }
    async getVersionNumber() {
        return this.executeReadMethod("getVersionNumber", []);
    }
    async getAttestationIdCounter() {
        return this.executeReadMethod("getAttestationIdCounter", []);
    }
    async balanceOf(account, id) {
        return this.executeReadMethod("balanceOf", [account, id]);
    }
    async balanceOfBatch(accounts, ids) {
        return this.executeReadMethod("balanceOfBatch", [accounts, ids]);
    }
    async executeReadMethod(functionName, args) {
        return this.web3Client.readContract({
            abi: AttestationRegistry_1.abiAttestationRegistry,
            address: this.conf.attestationRegistryAddress,
            functionName,
            args,
        });
    }
    async simulateContract(functionName, args) {
        if (!this.walletClient)
            throw new Error("VeraxSDK - Wallet not available");
        try {
            const { request } = await this.web3Client.simulateContract({
                address: this.conf.attestationRegistryAddress,
                abi: AttestationRegistry_1.abiAttestationRegistry,
                functionName,
                account: this.walletClient.account,
                args,
            });
            return request;
        }
        catch (err) {
            (0, simulationErrorHandler_1.handleSimulationError)(err);
        }
    }
}
exports.default = AttestationDataMapper;
//# sourceMappingURL=AttestationDataMapper.js.map