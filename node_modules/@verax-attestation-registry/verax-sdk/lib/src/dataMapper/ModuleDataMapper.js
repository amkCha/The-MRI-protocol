"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const BaseDataMapper_1 = __importDefault(require("./BaseDataMapper"));
const ModuleRegistry_1 = require("../abi/ModuleRegistry");
const simulationErrorHandler_1 = require("../utils/simulationErrorHandler");
const transactionSender_1 = require("../utils/transactionSender");
const abiCoder_1 = require("../utils/abiCoder");
class ModuleDataMapper extends BaseDataMapper_1.default {
    constructor() {
        super(...arguments);
        this.typeName = "module";
        this.gqlInterface = `{
        id
        moduleAddress
        name
        description
  }`;
    }
    async simulateUpdateRouter(routerAddress) {
        return await this.simulateContract("updateRouter", [routerAddress]);
    }
    async updateRouter(routerAddress, waitForConfirmation = false) {
        const request = await this.simulateUpdateRouter(routerAddress);
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async simulateRegister(name, description, moduleAddress) {
        return await this.simulateContract("register", [name, description, moduleAddress]);
    }
    async register(name, description, moduleAddress, waitForConfirmation = false) {
        const request = await this.simulateRegister(name, description, moduleAddress);
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async simulateRunModules(modulesAddresses, attestationPayload, validationPayloads, value) {
        const matchingSchema = await this.veraxSdk.schema.findOneById(attestationPayload.schemaId);
        if (!matchingSchema) {
            throw new Error("No matching Schema");
        }
        const attestationData = (0, abiCoder_1.encode)(matchingSchema.schema, attestationPayload.attestationData);
        return this.simulateContract("runModules", [
            modulesAddresses,
            [attestationPayload.schemaId, attestationPayload.expirationDate, attestationPayload.subject, attestationData],
            validationPayloads,
            `0x${value}`,
        ]);
    }
    async runModules(modulesAddresses, attestationPayload, validationPayloads, value, waitForConfirmation = false) {
        const request = await this.simulateRunModules(modulesAddresses, attestationPayload, validationPayloads, value);
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async simulateBulkRunModules(modulesAddresses, attestationPayloads, validationPayloads) {
        const attestationPayloadsArg = [];
        for (const attestationPayload of attestationPayloads) {
            const matchingSchema = await this.veraxSdk.schema.findOneById(attestationPayload.schemaId);
            if (!matchingSchema) {
                throw new Error("No matching Schema");
            }
            const attestationData = (0, abiCoder_1.encode)(matchingSchema.schema, attestationPayload.attestationData);
            attestationPayloadsArg.push([
                attestationPayload.schemaId,
                attestationPayload.expirationDate,
                attestationPayload.subject,
                attestationData,
            ]);
        }
        return await this.simulateContract("bulkRunModules", [
            modulesAddresses,
            attestationPayloadsArg,
            validationPayloads,
        ]);
    }
    async bulkRunModules(modulesAddresses, attestationPayloads, validationPayloads, waitForConfirmation = false) {
        const request = await this.simulateBulkRunModules(modulesAddresses, attestationPayloads, validationPayloads);
        return (0, transactionSender_1.executeTransaction)(request, this.web3Client, this.walletClient, waitForConfirmation);
    }
    async isContractAddress(contractAddress) {
        return await this.executeReadMethod("isContractAddress", [contractAddress]);
    }
    async getModulesNumber() {
        return await this.executeReadMethod("getModulesNumber", []);
    }
    async isRegistered(moduleAddress) {
        return await this.executeReadMethod("isRegistered", [moduleAddress]);
    }
    async getModuleAddress(index) {
        return await this.executeReadMethod("moduleAddresses", [index]);
    }
    async getModule(moduleAddress) {
        return await this.executeReadMethod("modules", [moduleAddress]);
    }
    async executeReadMethod(functionName, args) {
        return await this.web3Client.readContract({
            abi: ModuleRegistry_1.abiModuleRegistry,
            address: this.conf.moduleRegistryAddress,
            functionName,
            args,
        });
    }
    async simulateContract(functionName, args) {
        if (!this.walletClient)
            throw new Error("VeraxSDK - Wallet not available");
        try {
            const { request } = await this.web3Client.simulateContract({
                address: this.conf.moduleRegistryAddress,
                abi: ModuleRegistry_1.abiModuleRegistry,
                functionName,
                account: this.walletClient.account,
                args,
            });
            return request;
        }
        catch (err) {
            (0, simulationErrorHandler_1.handleSimulationError)(err);
        }
    }
}
exports.default = ModuleDataMapper;
//# sourceMappingURL=ModuleDataMapper.js.map