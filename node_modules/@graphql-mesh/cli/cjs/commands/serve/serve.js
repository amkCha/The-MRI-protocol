"use strict";
/* eslint-disable import/no-nodejs-modules */
Object.defineProperty(exports, "__esModule", { value: true });
exports.serveMesh = void 0;
const tslib_1 = require("tslib");
/* eslint-disable dot-notation */
const cluster_1 = tslib_1.__importDefault(require("cluster"));
const os_1 = tslib_1.__importDefault(require("os"));
const uWebSockets_1 = require("graphql-ws/lib/use/uWebSockets");
const open_1 = tslib_1.__importDefault(require("open"));
const cross_helpers_1 = require("@graphql-mesh/cross-helpers");
const http_1 = require("@graphql-mesh/http");
const utils_1 = require("@graphql-mesh/utils");
function portSelectorFn(sources, logger) {
    const port = sources.find(source => Boolean(source)) || 4000;
    if (sources.filter(source => Boolean(source)).length > 1) {
        const activeSources = [];
        if (sources[0]) {
            activeSources.push('CLI');
        }
        if (sources[1]) {
            activeSources.push('serve configuration');
        }
        if (sources[2]) {
            activeSources.push('environment variable');
        }
        logger.warn(`Multiple ports specified (${activeSources.join(', ')}), using ${port}`);
    }
    return port;
}
async function serveMesh({ baseDir, argsPort, getBuiltMesh, logger, rawServeConfig = {}, playgroundTitle, }, cliParams) {
    const { fork: configFork = cross_helpers_1.process.env.NODE_ENV?.toLowerCase() === 'production', port: configPort, hostname = os_1.default.platform() === 'win32' ||
        // is WSL?
        os_1.default.release().toLowerCase().includes('microsoft')
        ? '127.0.0.1'
        : '0.0.0.0', sslCredentials, endpoint: graphqlPath = '/graphql', browser = cross_helpers_1.process.env.NODE_ENV?.toLowerCase() !== 'production',
    // TODO
    // trustProxy = 'loopback',
     } = rawServeConfig;
    const port = portSelectorFn([argsPort, parseInt(configPort?.toString()), parseInt(cross_helpers_1.process.env.PORT)], logger);
    let forkNum;
    const envFork = cross_helpers_1.process.env.FORK;
    let defaultForkNum = 0;
    try {
        defaultForkNum = os_1.default.availableParallelism();
    }
    catch (e) {
        try {
            defaultForkNum = os_1.default.cpus().length;
        }
        catch (e) {
            // ignore
        }
    }
    if (envFork != null) {
        if (envFork === 'false' || envFork === '0') {
            forkNum = 0;
        }
        else if (envFork === 'true') {
            forkNum = defaultForkNum;
        }
        else {
            forkNum = parseInt(envFork);
        }
    }
    else if (configFork != null) {
        if (typeof configFork === 'boolean') {
            forkNum = configFork ? defaultForkNum : 0;
        }
        else {
            forkNum = configFork;
        }
    }
    const protocol = sslCredentials ? 'https' : 'http';
    const serverUrl = `${protocol}://${hostname}:${port}`;
    if (!playgroundTitle) {
        playgroundTitle = rawServeConfig?.playgroundTitle || cliParams.playgroundTitle;
    }
    if (!cluster_1.default.isWorker && forkNum > 1) {
        let mainProcessKilled = false;
        (0, utils_1.registerTerminateHandler)(eventName => {
            mainProcessKilled = true;
        });
        for (let i = 0; i < forkNum; i++) {
            const worker = cluster_1.default.fork();
            (0, utils_1.registerTerminateHandler)(eventName => worker.kill(eventName));
        }
        logger.info(`${cliParams.serveMessage}: ${serverUrl} in ${forkNum} forks`);
        cluster_1.default.on('exit', (worker, code, signal) => {
            if (!mainProcessKilled) {
                logger.child(`Worker ${worker.id}`).error(`died with ${signal || code}. Restarting...`);
                const newWorker = cluster_1.default.fork();
                (0, utils_1.registerTerminateHandler)(eventName => newWorker.kill(eventName));
            }
        });
    }
    else {
        if (cluster_1.default.isWorker) {
            logger.addPrefix?.(`Worker ${cluster_1.default.worker?.id}`);
        }
        logger.info(`Starting GraphQL Mesh...`);
        logger.info(`${cliParams.serveMessage}: ${serverUrl}`);
        (0, utils_1.registerTerminateHandler)(eventName => {
            const eventLogger = logger.child(`${eventName}  ðŸ’€`);
            eventLogger.info(`Destroying GraphQL Mesh...`);
            getBuiltMesh()
                .then(mesh => mesh.destroy())
                .catch(e => eventLogger.error(e));
        });
        let uWebSocketsApp;
        const meshHTTPHandler = (0, http_1.createMeshHTTPHandler)({
            baseDir,
            getBuiltMesh,
            rawServeConfig,
            playgroundTitle,
        });
        if (sslCredentials) {
            const { SSLApp } = await Promise.resolve().then(() => tslib_1.__importStar(require('uWebSockets.js')));
            uWebSocketsApp = SSLApp({
                key_file_name: sslCredentials.key,
                cert_file_name: sslCredentials.cert,
            });
        }
        else {
            const { App } = await Promise.resolve().then(() => tslib_1.__importStar(require('uWebSockets.js')));
            uWebSocketsApp = App();
        }
        uWebSocketsApp.any('/*', meshHTTPHandler);
        const wsHandler = (0, uWebSockets_1.makeBehavior)({
            execute: args => args.rootValue.execute(args),
            subscribe: args => args.rootValue.subscribe(args),
            onSubscribe: async (ctx, msg) => {
                const { getEnveloped } = await getBuiltMesh();
                const { schema, execute, subscribe, contextFactory, parse, validate } = getEnveloped(ctx);
                const args = {
                    schema,
                    operationName: msg.payload.operationName,
                    document: parse(msg.payload.query),
                    variableValues: msg.payload.variables,
                    contextValue: await contextFactory(),
                    rootValue: {
                        execute,
                        subscribe,
                    },
                };
                const errors = validate(args.schema, args.document);
                if (errors.length)
                    return errors;
                return args;
            },
        });
        uWebSocketsApp.ws(graphqlPath, wsHandler);
        uWebSocketsApp.listen(hostname, port, listenSocket => {
            if (!listenSocket) {
                logger.error(`Failed to listen to ${serverUrl}`);
                cross_helpers_1.process.exit(1);
            }
            (0, utils_1.registerTerminateHandler)(async (eventName) => {
                const eventLogger = logger.child(`${eventName}  ðŸ’€`);
                eventLogger.debug(`Stopping HTTP Server`);
                uWebSocketsApp?.close?.();
                eventLogger.debug(`HTTP Server has been stopped`);
            });
            if (browser) {
                (0, open_1.default)(serverUrl.replace('0.0.0.0', 'localhost'), typeof browser === 'string' ? { app: browser } : undefined).catch(() => { });
            }
        });
    }
    return null;
}
exports.serveMesh = serveMesh;
