"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.useFusiongraph = void 0;
const graphql_1 = require("graphql");
const graphql_yoga_1 = require("graphql-yoga");
const runtime_1 = require("@graphql-mesh/runtime");
const utils_1 = require("@graphql-mesh/utils");
const stitch_1 = require("@graphql-tools/stitch");
const utils_2 = require("@graphql-tools/utils");
const getSubschemasFromFusiongraph_js_1 = require("./getSubschemasFromFusiongraph.js");
const utils_js_1 = require("./utils.js");
function ensureSchema(source) {
    if ((0, graphql_1.isSchema)(source)) {
        return source;
    }
    if (typeof source === 'string') {
        return (0, graphql_1.buildSchema)(source, { assumeValid: true, assumeValidSDL: true });
    }
    if ((0, utils_2.isDocumentNode)(source)) {
        return (0, graphql_1.buildASTSchema)(source, { assumeValid: true, assumeValidSDL: true });
    }
    return source;
}
function useFusiongraph(opts) {
    let fusiongraph;
    let lastLoadedFusiongraph;
    let yoga;
    // TODO: We need to figure this out in a better way
    let inContextSDK;
    function handleLoadedFusiongraph(loadedFusiongraph) {
        if (loadedFusiongraph != null && lastLoadedFusiongraph === loadedFusiongraph) {
            return;
        }
        lastLoadedFusiongraph = loadedFusiongraph;
        fusiongraph = ensureSchema(loadedFusiongraph);
        const { transportEntryMap, subschemaMap, additionalTypeDefs, additionalResolversFromTypeDefs } = (0, getSubschemasFromFusiongraph_js_1.extractSubgraphsFromFusiongraph)(fusiongraph);
        const subgraphMap = new Map();
        const subschemas = [];
        const onSubgraphExecute = (0, utils_js_1.getOnSubgraphExecute)({
            fusiongraph,
            plugins: yoga.getEnveloped._plugins,
            transports: opts.transports || utils_js_1.defaultTransportsOption,
            transportBaseContext: opts.transportBaseContext,
            transportEntryMap,
            subgraphMap,
        });
        for (const [subschemaName, subschemaConfig] of subschemaMap) {
            subgraphMap.set(subschemaName, subschemaConfig.schema);
            subschemas.push({
                ...subschemaConfig,
                name: subschemaName,
                executor(execReq) {
                    return onSubgraphExecute(subschemaName, execReq);
                },
            });
        }
        fusiongraph = (0, stitch_1.stitchSchemas)({
            subschemas,
            assumeValid: true,
            assumeValidSDL: true,
            typeDefs: [opts.additionalTypedefs, ...additionalTypeDefs],
            resolvers: [
                opts.additionalResolvers,
                additionalResolversFromTypeDefs.map(additionalResolver => (0, utils_1.resolveAdditionalResolversWithoutImport)(additionalResolver)),
            ],
        });
        if (opts.additionalResolvers || additionalResolversFromTypeDefs.length) {
            const onDelegateHooks = [];
            for (const plugin of yoga.getEnveloped._plugins) {
                if (plugin.onDelegate) {
                    onDelegateHooks.push(plugin.onDelegate);
                }
            }
            inContextSDK = (0, runtime_1.getInContextSDK)(fusiongraph, subschemas, opts.transportBaseContext?.logger, onDelegateHooks);
        }
    }
    function getAndSetFusiongraph() {
        const supergraph$ = opts.getFusiongraph(opts.transportBaseContext);
        return (0, utils_1.mapMaybePromise)(supergraph$, handleLoadedFusiongraph);
    }
    if (opts.polling) {
        setInterval(getAndSetFusiongraph, opts.polling);
    }
    let initialFusiongraph$;
    let initiated = false;
    function ensureFusiongraph() {
        if (!initiated) {
            initialFusiongraph$ = getAndSetFusiongraph();
        }
        initiated = true;
        return initialFusiongraph$;
    }
    return {
        onYogaInit(payload) {
            yoga = payload.yoga;
        },
        onPluginInit({ addPlugin }) {
            if (opts.readinessCheckEndpoint) {
                addPlugin(
                // TODO: fix useReadinessCheck typings to inherit the context
                (0, graphql_yoga_1.useReadinessCheck)({
                    endpoint: opts.readinessCheckEndpoint,
                    check() {
                        const initialFusiongraph$ = ensureFusiongraph();
                        if ((0, utils_2.isPromise)(initialFusiongraph$)) {
                            return initialFusiongraph$.then(() => !!fusiongraph);
                        }
                        return !!fusiongraph;
                    },
                }));
            }
        },
        onRequestParse() {
            return {
                onRequestParseDone() {
                    return ensureFusiongraph();
                },
            };
        },
        onEnveloped({ setSchema }) {
            setSchema(fusiongraph);
        },
        onContextBuilding({ extendContext }) {
            const initialFusiongraph$ = ensureFusiongraph();
            function handleInitiatedFusiongraph() {
                if (inContextSDK) {
                    extendContext(inContextSDK);
                }
                extendContext(opts.transportBaseContext);
            }
            if ((0, utils_2.isPromise)(initialFusiongraph$)) {
                return initialFusiongraph$.then(handleInitiatedFusiongraph);
            }
            handleInitiatedFusiongraph();
        },
        invalidateUnifiedGraph() {
            return getAndSetFusiongraph();
        },
    };
}
exports.useFusiongraph = useFusiongraph;
